import matplotlib.pyplot as pltfrom scipy.optimize import minimizefrom scipy.optimize import minimize_scalarfrom subprocess import Popen, PIPE, callfrom multiprocessing import Poolfrom multiprocessing import Process,Value, Arrayfrom scipy.stats import pearsonrimport skimage.ioimport mathfrom math import piimport timefrom datetime import datetimeimport pygmo as pgimport numpy as npimport subprocessimport fileinputimport shutilimport globimport sysimport osimport xml.etree.ElementTree as ET################################### Read xmf mapping file:############################################def readKeywordInXMFFile(keyWord0,xmfFileNames):    print("a ====== ", xmfFileNames)    tree = ET.parse(xmfFileNames)    print("a ====== ", xmfFileNames)    root = tree.getroot()    counter = 0    tempString = root[0][0].attrib.get('Value')    myString = tempString.split()    nPores   = int(myString[0])-2    nThroats   = int(myString[1])    nElements   = int(myString[2])    for Grid in root[0][3].findall('Grid'):        for child1 in Grid.findall('Information'):            if(child1.attrib.get('Name')==keyWord0):                tempString = child1.text                myString = tempString.split()                if(int(myString[0])>0):                    counter = counter+1                #else:                    #print('HERE!',myString[0])    print('counter = ',counter)    ffazPores   = np.zeros((nPores,counter))    SwPores     = np.zeros((nPores,counter))    ffazThroats = np.zeros((nThroats,counter))    ffazTemp    = np.zeros(nElements)    SwTemp      = np.zeros(nElements)        i=0    print('nP = ',nPores)    print('nT = ',nThroats)        for Grid in root[0][3].findall('Grid'):        #print('***',i)        gridContinue=False        for child1 in Grid.findall('Information'):            if(child1.attrib.get('Name')==keyWord0):                tempString = child1.text                myString = tempString.split()                if(int(myString[0])==0):                    gridContinue = True;                    print('I am here')        if(gridContinue):            continue         for child in Grid.findall('Attribute'):            if(child.attrib.get('Name')=='ffaz' and child.attrib.get('Center')=='Node'):                print('i = ',i)                for temp in child.findall('DataItem'):                    ffazTemp = np.fromstring(temp.text, dtype=int, sep=' ')                    print(len(ffazTemp))                    ffazPores[:,i]=ffazTemp[2:nPores+2]# = np.fromstring(temp.text, dtype=int, sep=' ')                    ffazThroats[:,i]=ffazTemp[nPores+2:nPores+nThroats+2]            if(child.attrib.get('Name')=='So' and child.attrib.get('Center')=='Node'):                print('i = ',i)                for temp in child.findall('DataItem'):                    SwTemp = np.fromstring(temp.text, dtype=float, sep=' ')                    print((SwTemp[2:nPores+2]))                    SwPores[:,i]=SwTemp[2:nPores+2]        i=i+1    ffazPores = ffazPores.astype(int)    ffazThroats = ffazThroats.astype(int)    return counter,ffazPores,ffazThroats,1-SwPores############################################################################################                                  Read vtu file function:                             ############################################################################################def folderPath(inputAddres):    global originalPath    originalPath = inputAddresdef updatePoreThroatVolume(originalPath,inputAddress):    #global originalPath    if not os.path.exists(inputAddress):        os.mkdir(inputAddress)    else:        shutil.rmtree(inputAddress)        os.mkdir(inputAddress)    for item in os.listdir(originalPath):        if(item.endswith('.dat')):            shutil.copy(originalPath+item, inputAddress)    originalPath = inputAddress + '/'    with os.scandir(originalPath) as entries:        for entry in entries:            if entry.is_file():                if entry.name.endswith("_link2.dat"):                    f = open(originalPath+entry.name)                    temp = np.loadtxt(f)                    temp[:,6] = VthroatNew                    ######################                    temp[:,3] = lPore1New                    temp[:,4] = lPore2New                    temp[:,5] = lThroatNew                    ######################                    f.close()                    os.remove(originalPath+entry.name)                    np.savetxt(originalPath+entry.name,temp,fmt='%6d %6d %6d %.6e %.6e %.6e %.6e %.6e')                elif entry.name.endswith("_node2.dat"):                    f = open(originalPath+entry.name)                    temp = np.loadtxt(f)                    temp[:,1] = VporeNew                    f.close()                    os.remove(originalPath+entry.name)                    np.savetxt(originalPath+entry.name,temp,fmt='%6d %.6e %.6e %.6e %.6e')    return inputAddressdef readExpDataDAT(inputAddres):    global originalPath, tOut1,tOut2,pOut,fExpPore,fExpThroat,SwExpPore,SectionPart,SectionPartThroat,NN,poreCA,throatCA,throatFraction,poreCN    SectionPart = '<PointData>'    SectionPartThroat = '<CellData Scalars = "ffaz">'    originalPath = inputAddres    with os.scandir(originalPath) as entries:        for entry in entries:            if entry.is_file():                if entry.name.endswith("_link2.dat"):                    temp = np.genfromtxt(originalPath+entry.name, delimiter="", unpack=True)                    throatVolume = temp[6,:]                    NumberOfThroats = len(throatVolume);                    tOut2 = temp;                elif entry.name.endswith("_link1.dat"):                    temp = np.genfromtxt(originalPath+entry.name, delimiter="",skip_header=True, unpack=True)                    throatRadius = temp[3,:]                    tOut1 = temp                elif entry.name.endswith("_link3.dat"):                    temp = np.genfromtxt(originalPath+entry.name, delimiter="",skip_header=True, unpack=True)                    temp1 = np.sum(temp[4:,:],axis=0)                    print(temp1)                    throatFraction = temp[4:,:]/temp1                    throatFraction[0,np.isnan(throatFraction[0,:])]=0.5                    throatFraction[1,np.isnan(throatFraction[1,:])]=0.5                    print('throatFraction0',temp[0,np.isnan(throatFraction[0,:])])                    print('throatFraction1',temp[0,np.isnan(throatFraction[1,:])])                  elif entry.name.endswith("_node2.dat"):                    temp = np.genfromtxt(originalPath+entry.name, delimiter="", unpack=True)                    poreVolume = temp[1,:]                    poreRadius = temp[2,:]                    pOut = temp                    NumberOfPores = len(poreRadius);                elif entry.name.endswith("_node1.dat"):                    f = open(originalPath+entry.name)                    temp = np.loadtxt(f, skiprows=1, usecols=[4])                    print(temp)                    poreCN = temp[:]                    f.close()                elif entry.name.startswith("fw"):                    temp = np.genfromtxt(originalPath+entry.name, delimiter="", unpack=True)                    print(temp)                    fw = temp[:]                    print("fw = ",fw)                elif entry.name.endswith("CAFile_pores.dat"):                    poreCA = np.loadtxt(originalPath+entry.name)                elif entry.name.endswith("CAFile_throats.dat"):                    throatCA = np.loadtxt(originalPath+entry.name)    print("number of pores = ",NumberOfPores)    ##########################################################################################    ##                                  Find vtu file                                       ##    ##########################################################################################    fExpPore   = np.loadtxt(originalPath+'fPores.dat')    fExpThroat = np.loadtxt(originalPath+'fThroats.dat')    SwExpPore  = np.loadtxt(originalPath+'SwPores.dat')    NN = np.shape(fExpPore)[0]    print('NN = ',NN)    return tOut1,tOut2,pOut,fExpPore,fExpThroat,SwExpPore,throatFraction    def keywordFinder(keyWord0,SectionPart,FileNames):    out = None;    keyWord= '<DataArray type = "Float32" Name = "' + keyWord0 +'" format = "ascii">';    fileID = open(FileNames,'r');    filetext = fileID.read()    fileID.close()    result2 = filetext.find(SectionPart)    textTemp = filetext[result2:]    result = textTemp.find(keyWord)    if result<0:        return False    else:        return True    def readKeywordInFile(keyWord0,SectionPart,InitialElements,NumberOfElements,FileNames):    out = None;    keyWord= '<DataArray type = "Float32" Name = "' + keyWord0 +'" format = "ascii">';    fileID = open(FileNames,'r');    filetext = fileID.read()    fileID.close()    result2 = filetext.find(SectionPart)    textTemp = filetext[result2:]    result = textTemp.find(keyWord)    if result<0:        return out    textTemp = textTemp[(result+len(keyWord)):]    splittedString = textTemp.split()          out = np.array(splittedString[InitialElements:(NumberOfElements+InitialElements)],dtype=int);    return outdef readSwKeywordInFile(keyWord0,SectionPart,InitialElements,NumberOfElements,FileNames):    out = None;    keyWord= '<DataArray type = "Float32" Name = "' + keyWord0 +'" format = "ascii">';    fileID = open(FileNames,'r');    filetext = fileID.read()    fileID.close()    result2 = filetext.find(SectionPart)    textTemp = filetext[result2:]    result = textTemp.find(keyWord)    if result<0:        return out    textTemp = textTemp[(result+len(keyWord)):]    splittedString = textTemp.split()          out = np.array(splittedString[InitialElements:(NumberOfElements+InitialElements)],dtype=float);    return outdef readMappingResults( frequencyBasedDistribution):    global SectionPart,SectionPartThroat,NN    with os.scandir(originalPath) as entries:        for entry in entries:            if entry.is_file():                if entry.name.endswith("_link2.dat"):                    temp = np.genfromtxt(originalPath+entry.name, delimiter="", unpack=True)                    throatVolume = temp[6,:]                    NumberOfThroats = len(throatVolume);                    tOut2 = temp;                elif entry.name.endswith("_link1.dat"):                    temp = np.genfromtxt(originalPath+entry.name, delimiter="",skip_header=True, unpack=True)                    throatRadius = temp[3,:]                    tOut1 = temp                elif entry.name.endswith("_node2.dat"):                    temp = np.genfromtxt(originalPath+entry.name, delimiter="", unpack=True)                    poreVolume = temp[1,:]                    poreRadius = temp[2,:]                    pOut = temp                    NumberOfPores = len(poreRadius);                elif entry.name.startswith("fw"):                    temp = np.genfromtxt(originalPath+entry.name, delimiter="", unpack=True)                    print(temp)                    fw = temp[:]                    print("fw = ",fw)        print("number of pores = ",NumberOfPores)    ##########################################################################################    ##                                  Find vtu file                                       ##    ##########################################################################################    if frequencyBasedDistribution == "y":        poreVolume = np.ones(len(poreRadius))          throatVolume = np.ones(len(throatRadius))      #FileNames = "Temp_0_InitEnd_match.vtu"    print("===========================================================================")    FileNames = None    with os.scandir(originalPath) as entries:        for entry in entries:            if entry.is_file():                if entry.name.endswith(".vtu"):                    print('do you want to run ',entry.name)                    a = "y";#input('y for yess = ')                    if (a == "y"):                        print("File name = ",entry.name)                        FileNames = entry.name;                        break;                   if FileNames is None:        sys.exit("Error message")    print("===========================================================================")    ##################             Read Experimental Data             #################    #NN=8    SectionPart = '<PointData>';    SectionPartThroat = '<CellData Scalars = "ffaz">';    NN = 0    while True:        keyWord0 = "ffExp"+str(NN+1)+str(NN+1)            temp = keywordFinder(keyWord0,SectionPart,originalPath+FileNames)        print(keyWord0)        if temp is not True:            break        NN = NN+1    fExpPore = np.zeros((NN,NumberOfPores))    SwExpPore= np.zeros((NN,NumberOfPores))    fExpThroat = np.zeros((NN,NumberOfThroats))        writeFilname = 'BentheimerWaterWetLewis'        for i in range(NN):          keyWord0  = "ffExp"+str(i+1)+str(i+1)        keyWordSw = "SwExp"+str(i+1)+str(i+1)        fExpPore[i,:] = readKeywordInFile(keyWord0,SectionPart,2,NumberOfPores,originalPath+FileNames)        SwExpPore[i,:] = readSwKeywordInFile(keyWordSw,SectionPart,2,NumberOfPores,originalPath+FileNames)                fExpThroat[i,:] = readKeywordInFile(keyWord0,SectionPart,NumberOfPores+2,NumberOfThroats,originalPath+FileNames)    np.savetxt(originalPath+'SwPores.dat',SwExpPore,fmt='%.6f')#.transpose()    np.savetxt(originalPath+'fPores.dat',fExpPore,fmt='%.1d')#.transpose()    np.savetxt(originalPath+'fThroats.dat',fExpThroat,fmt='%.1d')#.transpose()    np.savetxt(originalPath+writeFilname+'_pores.dat',1-fExpPore[0,:].transpose(),fmt='%.1d')    np.savetxt(originalPath+writeFilname+'_throats.dat',1-fExpThroat[0,:].transpose(),fmt='%.1d')    return tOut1,tOut2,pOut,fExpPore,fExpThroat,SwExpPoredef readExpDataVTU():    global tOut1,tOut2,pOut,fExpPore,fExpThroat,SwExpPore#,y    tOut1, tOut2, pOut, fExpPore, fExpThroat,SwExpPore = readMappingResults(False)    #y = [2, 1.5, pi]############################################################################################                                  Read tif image function:                            ############################################################################################def readExpDataTiffImage(originalPath,imageBaseName, ElementSpacing,xDirection):    global SectionPart,SectionPartThroat,NN,tOut1,tOut2,pOut,fExpPore,fExpThroat    #print('Start!')    SectionPart = '<PointData>';    SectionPartThroat = '<CellData Scalars = "ffaz">';        with os.scandir(originalPath) as entries:        for entry in entries:            if entry.is_file():                print(entry.name)                if entry.name.endswith("_link2.dat"):                    temp = np.genfromtxt(originalPath+entry.name, delimiter="", unpack=True)                    throatVolume = temp[6,:]                    tOut2 = temp;                    NumberOfThroats = len(throatVolume);                elif entry.name.endswith("_link1.dat"):                    temp = np.genfromtxt(originalPath+entry.name, delimiter="",skip_header=True, unpack=True)                    throatRadius = temp[3,:]                         tOut1 = temp                elif entry.name.endswith("_link3.dat"):                    temp = np.genfromtxt(originalPath+entry.name, delimiter="",skip_header=True, unpack=True)                    throatLocation = temp[3:,:]  #3                 elif entry.name.endswith("_node1.dat"):                    f = open(originalPath+entry.name)                    temp = np.loadtxt(f, skiprows=1, usecols=[0,1,2,3])                    poreLocation = temp[:,1:]                    f.close()                elif entry.name.endswith("_node2.dat"):                    temp = np.genfromtxt(originalPath+entry.name, delimiter="", unpack=True)                    poreVolume = temp[1,:]                    poreRadius = temp[2,:]                    pOut = temp                    NumberOfPores = len(poreRadius);                elif (entry.name.endswith(".mhd")) and (entry.name.startswith(imageBaseName+str(0))):                    f = open(originalPath+entry.name)                    for line in f:                        string = line.split()                        if(len(string)>0):                            if (string[0]=='offset')or(string[0]=='Offset'):                                offsetB = [float(string[2]),float(string[3]),float(string[4])]     print("nPores   = ", NumberOfPores)    print("nThroats = ", NumberOfThroats)     tiffCounter = len(glob.glob1(originalPath,"*.tif"))    NN = tiffCounter        fExpPore = np.zeros((NumberOfPores,tiffCounter))    fExpThroat = np.zeros((NumberOfThroats,tiffCounter))    VExpPore = np.zeros((NumberOfPores,1))    SwExpPore = np.zeros((NumberOfPores,tiffCounter))    if (xDirection == 'x' or xDirection == 'X'):        xIndex = 2        yIndex = 1        zIndex = 0    elif (xDirection == 'y' or xDirection == 'Y'):                xIndex = 1        yIndex = 2        zIndex = 0    elif (xDirection == 'z' or xDirection == 'Z'):                xIndex = 0        yIndex = 1        zIndex = 2    print('offsetB[zIndex] = ',offsetB[zIndex])    print('offsetB[yIndex] = ',offsetB[yIndex])    print('offsetB[xIndex] = ',offsetB[xIndex])    refImage = skimage.io.imread(originalPath+imageBaseName +'_VElems.tif')    for iZ in range(Nz):        for iY in range(Ny):            for iX in range(Nx):                VExpPore[refImage[iX,iY,iZ].astype(int),0] = VExpPore[refImage[iX,iY,iZ].astype(int),0]+(refImage[iX,iY,iZ]>0)*1.0    for iFile in range(tiffCounter-1):                imArray = skimage.io.imread(originalPath+imageBaseName +str(iFile+1)+'.tif')        temp = np.shape(imArray)        print(originalPath+imageBaseName +str(iFile)+'.tif')        Nx = temp[xIndex]        Ny = temp[yIndex]        Nz = temp[zIndex]        iPoint = np.int_([0,0,0])        print(offsetB)        for iP in range(NumberOfPores):            iPoint[xIndex] = int(math.floor((poreLocation[iP,0]-offsetB[zIndex])/ElementSpacing))            iPoint[yIndex] = int(math.floor((poreLocation[iP,1]-offsetB[yIndex])/ElementSpacing))            iPoint[zIndex] = int(math.floor((poreLocation[iP,2]-offsetB[xIndex])/ElementSpacing))            #print(iP,' = ',iPoint)            fExpPore[iP,iFile] = imArray[iPoint[0],iPoint[1], iPoint[2]]              #fExpPore[(fExpPore[:,iFile]>2),iFile]=2        ElementSpacingT=1        for iT in range(NumberOfThroats):              iPoint[xIndex] = int(math.floor((throatLocation[0,iT]-offsetB[zIndex])/ElementSpacing))#+offsetB[zIndex]/ElementSpacingT)))            iPoint[yIndex] = int(math.floor((throatLocation[1,iT]-offsetB[yIndex])/ElementSpacing))#+offsetB[yIndex]/ElementSpacingT)))            iPoint[zIndex] = int(math.floor((throatLocation[2,iT]-offsetB[xIndex])/ElementSpacing))#+offsetB[xIndex]/ElementSpacingT)))            #print(iPoint)            fExpThroat[iT,iFile] = imArray[iPoint[0],iPoint[1], iPoint[2]]        #fExpThroat[(fExpThroat[:,iFile]>2),iFile]=2                for iZ in range(Nz):            for iY in range(Ny):                for iX in range(Nx):                    SwExpPore[refImage[iX,iY,iZ].astype(int),iFile] = SwExpPore[refImage[iX,iY,iZ].astype(int),iFile]+(refImage[iX,iY,iZ]>0)*(imArray[iX,iY,iZ]==63)        SwExpPore[:,iFile] = SwExpPore[:,iFile]/VExpPore    np.savetxt(originalPath + 'fExpThroat.dat',fExpThroat)    np.savetxt(originalPath + 'fExpPore.dat'  ,fExpPore)    np.savetxt(originalPath + 'SwExpPore.dat'  ,SwExpPore)def RunPNM(pnFolder,inputFile):    tempAddress = os.getcwd()    os.chdir(tempAddress+pnFolder+"/")    cmd = os.system("pnflow_tom "+inputFile+" >/dev/null 2>&1")        os.chdir(tempAddress)'''def OFCall(x):    sName = "TempFolder" + str(x)    thetaPoreCorr = np.loadtxt(sName+'/cCAFile_pores.dat')    thetaThroatCorr = np.loadtxt(originalPath+'/cCAFile_throats.dat')    rndPore = np.random.permutation(len(thetaPoreCorr))    rndThroat = np.random.permutation(len(thetaThroatCorr))    os.remove(sName+'/CAFile_pores.dat')    os.remove(sName+'/CAFile_throats.dat')    thetaPoreCorr=thetaPoreCorr[rndPore]    thetaThroatCorr=thetaThroatCorr[rndThroat]    np.savetxt(sName+'/CAFile_pores.dat',thetaPoreCorr,fmt='%.2f')    np.savetxt(sName+'/CAFile_throats.dat',thetaThroatCorr,fmt='%.2f')    if not os.path.exists(sName):        os.mkdir(sName)        #print("Directory " , sName ,  " Created ")    else:            print("Directory " , sName ,  " already exists")        now = datetime.now()        sName = sName + now.strftime("%H:%M:%S")        os.mkdir(sName)                sPathName = sName+ "/" + sName + ".dat"         print(sName)        #shutil.copy('input_pnflow.dat', sName)       for item in os.listdir(originalPath):        if(item.endswith('.dat')):            shutil.copy(originalPath+item, sName)    replaceThetaOn  = False    replaceWeightOn = False    replaceSwImbibitionFinal = False    for line in fileinput.FileInput(sName+'/input_pnflow.dat', inplace=1):        tempString = line.split()        if(replaceThetaOn):            line = line.replace("XX XX", str(theta*180/pi - 10.0)+ ' '+str(theta*180/pi + 10.0))            replaceThetaOn = False        elif(replaceWeightOn):                        #line = line.replace("XX XX", str(x[0]*1.0e9)+ ' '+str(x[1]))            line = line.replace("XX XX", str(x[0]*15000)+ ' '+str(x[1]*15000))            replaceWeightOn = False        elif(replaceSwImbibitionFinal and tempString[0]=='XX'):            line = line.replace("XX", str(x))            replaceSwImbibitionFinal = False        elif("EQUIL_CON_ANG_FAKE" in line):            replaceThetaOn = True        #elif("PORE_FILL_PRMTR" in line):        elif("PORE_FILL_WGT_FAKE" in line):                        replaceWeightOn = True        elif("SAT_CONTROL" in line):            replaceSwImbibitionFinal = True                    sys.stdout.write(line)        a = os.getcwd()    os.chdir(a+"/" + sName)    cmd = os.system("pnflow_tom input_pnflow.dat >/dev/null 2>&1") #")#    while(cmd>0):        cmd = os.system("pnflow_tom input_pnflow.dat >/dev/null 2>&1") #")#        print("I am inside...")    #subprocess.call('pnflow_tom input_pnflow.dat >/dev/null 2>&1')    os.chdir(a)    print('===============')    print(cmd)    print('===============')    pnflowResultsFolderName = 'input_pnflow_res'    basePath                = sName + '/'    return sName'''def OFCallable(x,originalPath,ErrCalcMethod = 'V',Errplot = False):        global tOut1,tOut2,pOut,fExpPore,fExpThroat,SectionPart,SectionPartThroat,NN,tempIndex,fFazPore,fFazThroat    theta=1        sName = 'tempFolder'#folderName    '''    if not os.path.exists(sName):        os.mkdir(sName)        #print("Directory " , sName ,  " Created ")    else:            print("Directory " , sName ,  " already exists")        now = datetime.now()        sName = sName + now.strftime("%H:%M:%S")        os.mkdir(sName)        sPathName = sName+ "/" + sName + ".dat"         print(sName)        shutil.copy(originalPath+'input_pnflow.dat', sName)       for item in os.listdir(originalPath):        if(item.endswith('.dat')):            shutil.copy(originalPath+item, sName)    replaceThetaOn  = False    replaceWeightOn = False        for line in fileinput.FileInput(sName+'/input_pnflow.dat', inplace=1):        if(replaceThetaOn):            line = line.replace("XX XX", str(theta*180/pi - 10.0)+ ' '+str(theta*180/pi + 10.0))            replaceThetaOn = False        elif(replaceWeightOn):                        #line = line.replace("XX XX", str(x[0]*1.0e9)+ ' '+str(x[1]))            line = line.replace("XX XX", str(x[0]*15000)+ ' '+str(x[1]*15000))            replaceWeightOn = False                        elif("EQUIL_CON_ANG_Fake" in line):            replaceThetaOn = True        #elif("PORE_FILL_PRMTR" in line):        elif("PORE_FILL_WGT_Fake" in line):                        replaceWeightOn = True         sys.stdout.write(line)    a = os.getcwd()    os.chdir(a+"/" + sName)    cmd = os.system("pnflow_tom input_pnflow.dat >/dev/null 2>&1")            os.chdir(a)    #'''    pnflowResultsFolderName = 'input_pnflow_res'    basePath                = sName + '/'    NumberOfPores = len(pOut[2,:]);    NumberOfThroats= len(tOut1[3,:]);    if(ErrCalcMethod == 'F'):        poreVolume = np.ones(NumberOfPores)        throatVolume = np.ones(NumberOfThroats)    elif(ErrCalcMethod == 'V'):        poreVolume = pOut[1,:]        throatVolume = tOut2[6,:]    poreRadius = pOut[2,:]    throatRadius = tOut1[3,:]    poreVolumeSw = pOut[1,:]    throatVolumeSw = tOut2[6,:]        totalPoreVolume = np.sum(poreVolume);    totalThroatVolume = np.sum(throatVolume);    totalPoreVolumeSw = np.sum(poreVolumeSw);    totalThroatVolumeSw = np.sum(throatVolumeSw);    PNMbasePath = basePath + pnflowResultsFolderName+"/";    vtuCounter = len(glob.glob1(PNMbasePath,"2_WInj*.vtu"))    #print("Addres = ",PNMbasePath)    #print("number of PNM vtu files = ", vtuCounter)    fFazPore = np.zeros((vtuCounter, NumberOfPores))    fFazThroat = np.zeros((vtuCounter, NumberOfThroats))    SwPore = np.zeros((vtuCounter, NumberOfPores))    SwThroat = np.zeros((vtuCounter, NumberOfThroats))      fileNumber = np.zeros((vtuCounter,2))    nfnf = 0    keyWord0 = 'ffaz'    keyWord1 = 'Sw'    averageOilOccupancy = np.zeros((vtuCounter, 1));    averageSaturationPNM= np.zeros((vtuCounter, 1));    #print("pore Voume = ", np.sum(poreVolume),"throat Voume = ", np.sum(throatVolume))    with os.scandir(PNMbasePath) as entries:        for entry in entries:            if entry.is_file():                if entry.name.endswith(".vtu") & entry.name.startswith("2_WInj"):                    fFazPore[nfnf,:] = readKeywordInFile(keyWord0,SectionPart,1,NumberOfPores,PNMbasePath+entry.name)-1                    fFazThroat[nfnf,:] = readKeywordInFile(keyWord0,SectionPart,NumberOfPores+2,NumberOfThroats,PNMbasePath+entry.name)-1                    SwPore[nfnf,:] = readSwKeywordInFile(keyWord1,SectionPart,1,NumberOfPores,PNMbasePath+entry.name)#-1                    SwThroat[nfnf,:] = readSwKeywordInFile(keyWord1,SectionPart,NumberOfPores+2,NumberOfThroats,PNMbasePath+entry.name)#-1                    tempPoreFill = np.sum(poreVolume*(1-fFazPore[nfnf,:]))                     tempThroatFill = np.sum(throatVolume*(1-fFazThroat[nfnf,:]))                     averageOilOccupancy[nfnf,0] = (tempPoreFill+tempThroatFill)/(totalPoreVolume+totalThroatVolume)#(np.sum(poreVolume*fFazPore[nfnf,:])+np.sum(throatVolume*fFazThroat))/(np.sum(poreVolume)+np.sum(throatVolume))                    averageSaturationPNM[nfnf,0] = (np.sum(poreVolume*SwPore[nfnf,:])+np.sum(throatVolume*SwThroat[nfnf,:]))/(totalPoreVolume+totalThroatVolume)                    nfnf = nfnf + 1    #mat_sort = fileNumber[fileNumber[:,1].argsort()[::-1]]    poreOilOccupancyAD = np.zeros((NN,vtuCounter))    throatOilOccupancyAD = np.zeros((NN,vtuCounter))    poreOilOccupancyAAD = np.zeros((NN,vtuCounter))    throatOilOccupancyAAD = np.zeros((NN,vtuCounter))    print(np.shape(fFazPore))    print(np.shape(fExpPore))        for ii in range(NN):        for jj in range(nfnf):            poreOilOccupancyAD[ii,jj] = np.sum(poreVolume*(fFazPore[jj,:]-fExpPore[ii,:]))            throatOilOccupancyAD[ii,jj] = np.sum(throatVolume*(fFazThroat[jj,:]-fExpThroat[ii,:]))            poreOilOccupancyAAD[ii,jj] = np.sum(poreVolume*np.absolute(fFazPore[jj,:]-fExpPore[ii,:]))            throatOilOccupancyAAD[ii,jj] = np.sum(throatVolume*np.absolute(fFazThroat[jj,:]-fExpThroat[ii,:]))    #AD = np.zeros((NN,vtuCounter))    #AAD = np.zeros((NN,vtuCounter))    AD  = (poreOilOccupancyAD[:,:nfnf]+throatOilOccupancyAD[:,:nfnf])/(totalPoreVolume+totalThroatVolume)    AAD = (poreOilOccupancyAAD[:,:nfnf]+throatOilOccupancyAAD[:,:nfnf])/(totalPoreVolume+totalThroatVolume)    AADVector = np.zeros(NN)    ADVector = np.zeros(NN)    OccupancyExp = np.zeros(NN)    OccupancyPNM = np.zeros(NN)    tempIndex = [0]*NN;    for kk in range(NN):        #tempIndex[kk] = np.abs(averageSaturationPNM[:,0] - getSwFromImage(kk)).argmin()        #tempIndex[kk] = np.abs(AD[kk,:] - 0.0).argmin()        tempIndex[kk] = AAD[kk,:].argmin()        ADVector[kk] = AD[kk,tempIndex[kk]]        AADVector[kk]  = AAD[kk,tempIndex[kk]]        OccupancyExp[kk] = 1-(np.sum(poreVolumeSw*(fExpPore[kk,:]))+np.sum(throatVolumeSw*fExpThroat[kk,:]))/(totalPoreVolumeSw+totalThroatVolumeSw)        OccupancyPNM[kk] = 1-(np.sum(poreVolumeSw*(fFazPore[tempIndex[kk],:]))+np.sum(throatVolumeSw*fFazThroat[tempIndex[kk],:]))/(totalPoreVolumeSw+totalThroatVolumeSw)    ##Remove the results of PNM Run:    #====================================================    #====================================================    #shutil.rmtree(sName)    #====================================================    #====================================================    if(Errplot):        nPlot = 1        Npoint=100        plt.figure(2*nPlot)        SaiTheory = np.linspace(0,1.0,Npoint)        ErrTheory = [0.0]*Npoint        for i in range(Npoint):            ErrTheory[i] = 2.0*SaiTheory[i]*(1-SaiTheory[i])        plt.plot(OccupancyExp,AADVector,'-rx')        outWrite = np.zeros((NN,3))        outWrite[:,0] = OccupancyExp        outWrite[:,1] = ADVector        outWrite[:,2] = AADVector        np.savetxt(originalPath+'temp_Outf_faz.txt',outWrite,fmt='%.6f %.6f %.6f')        #np.savetxt(originalPath+'temp_AADVector.txt',AADVector,fmt='%.6f')        #np.savetxt(originalPath+'temp_OccupancyExp.txt',OccupancyExp,fmt='%.6f')        plt.plot(SaiTheory,ErrTheory,'g')        plt.title('Volume weighted average absolute error of pore-by-pore occupancy')#'A='+str(x[0])+', B='+str(x[1])+' and ${\Theta}$ = '+str(round(theta*180/pi))+"°")        #plt.title('Average absolute error of pore-by-pore occupancy-without volume weighting')#'A='+str(x[0])+', B='+str(x[1])+' and ${\Theta}$ = '+str(round(theta*180/pi))+"°")        plt.xlabel('Pore occupancy')        plt.ylabel('AAD')        plt.tick_params(direction='in')        axes = plt.gca()        axes.set_xlim([0,1.0])        axes.set_ylim([0,0.5])    plt.fill_between(OccupancyExp,AADVector,hatch="+", alpha=0.1, label='_nolegend_')    dx = 0.001    minX = np.min(OccupancyExp)    maxX = np.max(OccupancyExp)+dx    xData = np.arange(minX, maxX, dx)    plt.fill_between(xData,2*xData*(1-xData), alpha=0.5, label='_nolegend_')    #print('file',sName,'removed!')    #print(AADVector)    print("=======================================")      print("Err = " ,AADVector[-1])    print("=======================================")        print("SaiExp = ",OccupancyExp[-1])    print("=======================================")        print("SaiPNM = ",OccupancyPNM[-1])    print("=======================================")            #outTest[iThread] = sum(AADVector)    if os.path.exists('result'+ErrCalcMethod+str(x[1])+'.png'):        os.remove('result'+ErrCalcMethod+str(x[1])+'.png')    if os.path.exists('result'+ErrCalcMethod+str(x[1])+'.svg'):        os.remove('result'+ErrCalcMethod+str(x[1])+'.svg')    plt.savefig('result'+ErrCalcMethod+str(x[1])+'.png', dpi=300)    plt.savefig('result'+ErrCalcMethod+str(x[1])+'.svg')    tempY = (AADVector[0:NN-1]+AADVector[1:NN])/2.0    tempX = np.diff(OccupancyExp)    outArea  = sum(tempY*tempX)    AreaRandom = (OccupancyExp[-1]**2-(2.0/3.0)*OccupancyExp[-1]**3) - (OccupancyExp[0]**2-(2.0/3.0)*OccupancyExp[0]**3)     print("=======================================")      print("Area = " ,outArea/AreaRandom)    print("=======================================")        return sum(AADVector),sName#(x[0]-y[0])**2 + (x[1]-y[1])**2+ (theta-y[2])**2def OFCallableSw(x,folderName,originalPath,ErrCalcMethod = 'V',Errplot = False):        global tOut1,tOut2,pOut,SwExpPore,SectionPart,SectionPartThroat,NN,tempIndex,SWPore,throatFraction, SwPorePNMOF,SwThroatPNMOF,poreAndThroatVolume    theta=1    sName = folderName#'tempFolder'    '''    if not os.path.exists(sName):        os.mkdir(sName)        #print("Directory " , sName ,  " Created ")    else:            print("Directory " , sName ,  " already exists")        now = datetime.now()        sName = sName + now.strftime("%H:%M:%S")        os.mkdir(sName)        sPathName = sName+ "/" + sName + ".dat"         print(sName)        shutil.copy(originalPath+'input_pnflow.dat', sName)       for item in os.listdir(originalPath):        if(item.endswith('.dat')):            shutil.copy(originalPath+item, sName)    replaceThetaOn  = False    replaceWeightOn = False        for line in fileinput.FileInput(sName+'/input_pnflow.dat', inplace=1):        if(replaceThetaOn):            line = line.replace("XX XX", str(theta*180/pi - 10.0)+ ' '+str(theta*180/pi + 10.0))            replaceThetaOn = False        elif(replaceWeightOn):                        #line = line.replace("XX XX", str(x[0]*1.0e9)+ ' '+str(x[1]))            line = line.replace("XX XX", str(x[0]*15000)+ ' '+str(x[1]*15000))            replaceWeightOn = False                        elif("EQUIL_CON_ANG_Fake" in line):            replaceThetaOn = True        #elif("PORE_FILL_PRMTR" in line):        elif("PORE_FILL_WGT_Fake" in line):                        replaceWeightOn = True         sys.stdout.write(line)            a = os.getcwd()    os.chdir(a+"/" + sName)    cmd = os.system("pnflow_tom input_pnflow.dat >/dev/null 2>&1")            os.chdir(a)    '''    pnflowResultsFolderName = 'input_pnflow_res'    basePath                = sName + '/'    NumberOfPores = len(pOut[2,:]);    NumberOfThroats= len(tOut1[3,:]);    if(ErrCalcMethod == 'F'):        poreVolume = np.ones(NumberOfPores)        throatVolume = np.ones(NumberOfThroats)    elif(ErrCalcMethod == 'V'):        poreVolume = pOut[1,:]        throatVolume = tOut2[6,:]    poreRadius = pOut[2,:]    throatRadius = tOut1[3,:]    poreVolumeSw = pOut[1,:]    throatVolumeSw = tOut2[6,:]        totalPoreVolume = np.sum(poreVolume);    totalThroatVolume = np.sum(throatVolume);    totalPoreVolumeSw = np.sum(poreVolumeSw);    totalThroatVolumeSw = np.sum(throatVolumeSw);    poreAndThroatVolume = np.zeros((NumberOfPores))    vTemp = min(poreVolume[poreVolume>0])    poreVolume[poreVolume==0]=0.5*vTemp    vTemp = min(poreVolumeSw[poreVolumeSw>0])    poreVolumeSw[poreVolumeSw==0]=0.5*vTemp    vTemp = min(throatVolume[throatVolume>0])    throatVolume[throatVolume==0]=0.5*vTemp    vTemp = min(throatVolumeSw[throatVolumeSw>0])    throatVolumeSw[throatVolumeSw==0]=0.5*vTemp    for i in range(NumberOfThroats):        pi = tOut1[1,i].astype(int)-1        pj = tOut1[2,i].astype(int)-1        poreAndThroatVolume[pi] = poreAndThroatVolume[pi] + throatFraction[0,i]*throatVolume[i]        poreAndThroatVolume[pj] = poreAndThroatVolume[pj] + throatFraction[1,i]*throatVolume[i]    poreAndThroatVolume = poreAndThroatVolume+poreVolumeSw        #print('f',np.isnan(throatFraction[1,:]).any())        PNMbasePath = basePath + pnflowResultsFolderName+"/";    vtuCounter = len(glob.glob1(PNMbasePath,"2_WInj*.vtu"))    #print("Addres = ",PNMbasePath)    #print("number of PNM vtu files = ", vtuCounter)    SWPoreTemp = np.zeros((1, NumberOfPores))    SWPoresThroat = np.zeros((1, NumberOfPores))        SWThroatTemp = np.zeros((1, NumberOfThroats))         SWPore = np.zeros((vtuCounter, NumberOfPores))    SwPorePNMOF = np.zeros((vtuCounter, NumberOfPores))    SwThroatPNMOF = np.zeros((vtuCounter, NumberOfThroats))    #SWThroat = np.zeros((vtuCounter, NumberOfThroats))      fileNumber = np.zeros((vtuCounter,2))    nfnf = 0    keyWord0 = 'Sw'    averageOilSaturation = np.zeros((vtuCounter, 1));    #print("pore Voume = ", np.sum(poreVolume),"throat Voume = ", np.sum(throatVolume))    with os.scandir(PNMbasePath) as entries:        for entry in entries:            if entry.is_file():                if entry.name.endswith(".vtu") & entry.name.startswith("2_WInj"):                    SWPoresThroat = SWPoresThroat*0.0;                    SWPoreTemp = readSwKeywordInFile(keyWord0,SectionPart,1,NumberOfPores,PNMbasePath+entry.name)#-1                    SWThroatTemp = readSwKeywordInFile(keyWord0,SectionPart,NumberOfPores+2,NumberOfThroats,PNMbasePath+entry.name)#-1                    SwPorePNMOF[nfnf,:] = SWPoreTemp                    SwThroatPNMOF[nfnf,:] = SWThroatTemp                    #print('SWThroatTemp',np.isnan(SWThroatTemp).any())                    for i in range(NumberOfThroats):                        pi = tOut1[1,i].astype(int)-1                        pj = tOut1[2,i].astype(int)-1                        SWPoresThroat[0,pi] = SWPoresThroat[0,pi] + throatFraction[0,i]*throatVolume[i]*SWThroatTemp[i]                        SWPoresThroat[0,pj] = SWPoresThroat[0,pj] + throatFraction[1,i]*throatVolume[i]*SWThroatTemp[i]                    SWPore[nfnf,:] = ((SWPoreTemp*poreVolumeSw)+SWPoresThroat)/poreAndThroatVolume                    #print('AAAAA',np.isnan((0.0/poreAndThroatVolume)).any())                    #print('BBBBB',np.flatnonzero(poreAndThroatVolume == 0))                    #print('poreAndThroatVolume',poreAndThroatVolume[np.isnan(0.0/poreAndThroatVolume)])                    #print('poreAndThroatVolume',poreAndThroatVolume[np.isnan(0.0/poreAndThroatVolume)])                    tempPoreFill = np.sum(poreVolume*(SWPoreTemp))                    tempThroatFill = np.sum(throatVolume*(SWThroatTemp))                    averageOilSaturation[nfnf,0] = (tempPoreFill+tempThroatFill)/(totalPoreVolume+totalThroatVolume)#(np.sum(poreVolume*SWPore[nfnf,:])+np.sum(throatVolume*SWThroat))/(np.sum(poreVolume)+np.sum(throatVolume))                    nfnf = nfnf + 1    #mat_sort = fileNumber[fileNumber[:,1].argsort()[::-1]]    #res = minimize_scalar(ObjFunSw, bounds=(-3, 12), method='bounded')        poreOilSaturationAD = np.zeros((NN,vtuCounter))    #throatOilSaturationAD = np.zeros((NN,vtuCounter))    poreOilSaturationAAD = np.zeros((NN,vtuCounter))    #throatOilSaturationAAD = np.zeros((NN,vtuCounter))      for ii in range(NN):        for jj in range(nfnf):            poreOilSaturationAD[ii,jj] = np.sum(poreAndThroatVolume*(SWPore[jj,:]-SwExpPore[ii,:]))            #print('SwExpPore',np.isnan(SWPore[jj,:]).any())            #throatOilSaturationAD[ii,jj] = np.sum(throatVolume*(SWThroat[jj,:]-SwExpThroat[ii,:]))            poreOilSaturationAAD[ii,jj] = np.sum(poreAndThroatVolume*np.absolute(SWPore[jj,:]-SwExpPore[ii,:]))            #throatOilSaturationAAD[ii,jj] = np.sum(throatVolume*np.absolute(SWThroat[jj,:]-SwExpThroat[ii,:]))    #AD = np.zeros((NN,vtuCounter))    #AAD = np.zeros((NN,vtuCounter))    #print('++++++++++++++++++++++++')    #print('sum',np.isnan(poreAndThroatVolume*(SWPore[jj,:]-SwExpPore[ii,:])).any())    #print('SwExpPore',np.isnan(SWPore[jj,:]).any())    #print('poreAndThroatVolume',np.isnan(poreAndThroatVolume).any())    print('++++++++++++++++++++++++')        AD  = (poreOilSaturationAD[:,:nfnf])/(totalPoreVolume+totalThroatVolume)    AAD = (poreOilSaturationAAD[:,:nfnf])/(totalPoreVolume+totalThroatVolume)    AADVector = np.zeros(NN)    ADVector = np.zeros(NN)    SaturationExp = np.zeros(NN)    SaturationPNM = np.zeros(NN)    tempIndex = [0]*NN;    for kk in range(NN):               tempIndex[kk] = np.abs(AD[kk,:] - 0.0).argmin()        ADVector[kk] = AD[kk,tempIndex[kk]]        AADVector[kk]  = AAD[kk,tempIndex[kk]]        SaturationExp[kk] = (np.sum(poreAndThroatVolume*(SwExpPore[kk,:])))/(totalPoreVolumeSw+totalThroatVolumeSw)        SaturationPNM[kk] = (np.sum(poreAndThroatVolume*(SWPore[tempIndex[kk],:])))/(totalPoreVolumeSw+totalThroatVolumeSw)    ##Remove the results of PNM Run:    #====================================================    #====================================================    #shutil.rmtree(sName)    #====================================================    #====================================================    if(Errplot):        nPlot = 3        Npoint=100        plt.figure(2*(nPlot+1))        SaiTheory = np.linspace(0,1.0,Npoint)        ErrTheory = [0.0]*Npoint        for i in range(Npoint):            ErrTheory[i] = 2.0*SaiTheory[i]*(1-SaiTheory[i])        plt.plot(SaturationExp,AADVector,'-bx')        outWrite = np.zeros((NN,3))        outWrite[:,0] = SaturationExp        outWrite[:,1] = ADVector        outWrite[:,2] = AADVector        np.savetxt(originalPath+'temp_OutSw.txt',outWrite,fmt='%.6f %.6f %.6f')        #np.savetxt(originalPath+'temp_ADVectorSw.txt',ADVector,fmt='%.6f')        #np.savetxt(originalPath+'temp_AADVectorSw.txt',AADVector,fmt='%.6f')        #np.savetxt(originalPath+'temp_SaturationExp.txt',SaturationExp,fmt='%.6f')        #plt.plot(SaiTheory,ErrTheory,'g')        plt.title('Volume weighted average absolute error of pore-by-pore Saturation')#'A='+str(x[0])+', B='+str(x[1])+' and ${\Theta}$ = '+str(round(theta*180/pi))+"°")        #plt.title('Average absolute error of pore-by-pore Saturation-without volume weighting')#'A='+str(x[0])+', B='+str(x[1])+' and ${\Theta}$ = '+str(round(theta*180/pi))+"°")        plt.xlabel('Pore Saturation')        plt.ylabel('Average absolute error')        axes = plt.gca()        axes.set_xlim([0,1.0])        axes.set_ylim([0,0.5])            #print('file',sName,'removed!')    #print(AADVector)    print("=======================================")      print("ErrSw = " ,AADVector[-1])    print("=======================================")        print("SwExp = ",SaturationExp[:])    print("=======================================")        print("SwPNM = ",SaturationPNM[:])    print("=======================================")            #outTest[iThread] = sum(AADVector)    plt.tick_params(direction='in')    if os.path.exists('resultSw'+ErrCalcMethod+str(x[1])+'.png'):        os.remove('resultSw'+ErrCalcMethod+str(x[1])+'.png')    #else:        #os.mkdir(originalPath+'result')            plt.savefig('resultSw'+ErrCalcMethod+str(x[1])+'.png',dpi=300)    tempY = (AADVector[0:NN-1]+AADVector[1:NN])/2.0    tempX = np.diff(SaturationExp)    outArea  = sum(tempY*tempX)    AreaRandom = (SaturationExp[-1]**2-(2.0/3.0)*SaturationExp[-1]**3) - (SaturationExp[0]**2-(2.0/3.0)*SaturationExp[0]**3)     print("=======================================")      print("Area = " ,outArea/AreaRandom)    print("=======================================")        return sum(AADVector)#,sName#(x[0]-y[0])**2 + (x[1]-y[1])**2+ (theta-y[2])**2def OFCallableOptSw(x,folderName,originalPath,ErrCalcMethod = 'V',Errplot = False):        global tOut1,tOut2,pOut,SwExpPore,SectionPart,SectionPartThroat,NN,tempIndex,SWPore,throatFraction, SwPorePNMOF,SwThroatPNMOF,poreAndThroatVolume,SaturationExp    theta=1    sName = folderName#'tempFolder'        pnflowResultsFolderName = 'input_pnflow_res'    basePath                = sName + '/'    NumberOfPores = len(pOut[2,:]);    NumberOfThroats= len(tOut1[3,:]);    PNMbasePath = basePath + pnflowResultsFolderName+"/";    vtuCounter = len(glob.glob1(PNMbasePath,"2_WInj*.vtu"))    SwPorePNMOF = np.zeros((vtuCounter, NumberOfPores))    SwThroatPNMOF = np.zeros((vtuCounter, NumberOfThroats))    poreAndThroatVolume = np.zeros((NumberOfPores))    for i in range(NumberOfThroats):        pi = tOut1[1,i].astype(int)-1        pj = tOut1[2,i].astype(int)-1        poreAndThroatVolume[pi] = poreAndThroatVolume[pi] + throatFraction[0,i]*tOut2[6,i]        poreAndThroatVolume[pj] = poreAndThroatVolume[pj] + throatFraction[1,i]*tOut2[6,i]    poreAndThroatVolume = poreAndThroatVolume+pOut[1,:]    SaturationExp = np.zeros(NN)    for kk in range(NN):               SaturationExp[kk] = (np.sum(poreAndThroatVolume*(SwExpPore[kk,:])))/(np.sum(poreAndThroatVolume))#getSwFromImage2(kk)#    nfnf = 0    keyWord0 = 'Sw'    with os.scandir(PNMbasePath) as entries:        for entry in entries:            if entry.is_file():                if entry.name.endswith(".vtu") & entry.name.startswith("2_WInj"):                    #SWPoresThroat = SWPoresThroat*0.0;                    SWPoreTemp = readSwKeywordInFile(keyWord0,SectionPart,1,NumberOfPores,PNMbasePath+entry.name)#-1                    SWThroatTemp = readSwKeywordInFile(keyWord0,SectionPart,NumberOfPores+2,NumberOfThroats,PNMbasePath+entry.name)#-1                    SwPorePNMOF[nfnf,:] = SWPoreTemp                    SwThroatPNMOF[nfnf,:] = SWThroatTemp                    nfnf = nfnf + 1    res = minimize_scalar(ObjFunSw, bounds=(-0.5, 0.5), method='bounded')    print(ObjFunSw(res.x))    #print(ObjFunPerm(-0.35))    print("=================================")    print(np.sum(VporeNew-pOut[1,:]))    print(np.sum(VthroatNew-tOut2[6,:]))        print("best results of a = ",res.x)    print("=================================")    return 1def ObjFunSw(a):    #global tOut1,tOut2,pOut, SwPorePNMOF,SwThroatPNMOF,throatFraction,poreCN, NN, tempIndex, poreAndThroatVolume    global VporeNew, VthroatNew    Vpore = pOut[1,:]    Vthroat = tOut2[6,:]    NumberOfThroats= len(Vthroat);    if (a<0):        dVT = a * Vthroat        VthroatNew = Vthroat + dVT        tempIndex1 = tOut1[1,:].astype(int)-1        #Index1 = tempIndex1[tempIndex1>0]        tempIndex2 = tOut1[2,:].astype(int)-1        #Index2 = tempIndex2[tempIndex2>0]        VporeNew = Vpore;        for i in range(NumberOfThroats):            if(tempIndex1[i]>-1):                VporeNew[tempIndex1[i]] = VporeNew[tempIndex1[i]] - dVT[i] *throatFraction[0,i]            if(tempIndex2[i]>-1):                VporeNew[tempIndex2[i]] = VporeNew[tempIndex2[i]] - dVT[i] *throatFraction[1,i]    else:        dVP = a * Vpore/poreCN        dVP[poreCN==0]=0        VporeNew = (1-a)*Vpore        VthroatNew = Vthroat + dVP[tOut1[1,:].astype(int)-1]*throatFraction[0,:] + dVP[tOut1[2,:].astype(int)-1]*throatFraction[1,:]    out = 0.0    print('--------------------------------')    print(SaturationExp)    print('--------------------------------')    #print(tempIndex)    '''    #############################################################    kk =NN-1    tempSw =  (np.sum(SwPorePNMOF[tempIndex[kk],:] * VporeNew) + np.sum(SwThroatPNMOF[tempIndex[kk],:] *VthroatNew))/(np.sum(VporeNew) + np.sum(VthroatNew))    out = out + abs(tempSw - SaturationExp[kk])    #############################################################    #'''    for kk in range(NN):        tempSw =  (np.sum(SwPorePNMOF[tempIndex[kk],:] * VporeNew) + np.sum(SwThroatPNMOF[tempIndex[kk],:] *VthroatNew))/(np.sum(VporeNew) + np.sum(VthroatNew))        #SaturationExp = (np.sum(poreAndThroatVolume*(SwExpPore[kk,:])))/(np.sum(poreAndThroatVolume))        #print(VporeNew)        #print(SwPorePNMOF)        out = out + abs(tempSw - SaturationExp[kk])    #'''    #############################################################    #############################################################    #print(out)    return outdef ObjFunPerm(a):    global lPore1New, lPore2New, lThroatNew    lPore1 = tOut2[3,:]    lPore2 = tOut2[4,:]    lThroat = tOut2[5,:]    NumberOfThroats= len(lThroat)    if(a<0):        dlT1 = a * lThroat*throatFraction[0,:]        dlT2 = a * lThroat*throatFraction[1,:]    else:        dlT1 = a * lPore1        dlT2 = a * lPore2    lThroatNew = lThroat +( dlT1+dlT2)    lPore1New = lPore1 - dlT1    lPore2New = lPore2 - dlT2        out = 0.0    #print(tempIndex)    '''    #############################################################    kk =NN-1    tempSw =  (np.sum(SwPorePNMOF[tempIndex[kk],:] * VporeNew) + np.sum(SwThroatPNMOF[tempIndex[kk],:] *VthroatNew))/(np.sum(VporeNew) + np.sum(VthroatNew))    out = out + abs(tempSw - SaturationExp[kk])    #############################################################    #'''    '''    for kk in range(NN):        tempSw =  (np.sum(SwPorePNMOF[tempIndex[kk],:] * VporeNew) + np.sum(SwThroatPNMOF[tempIndex[kk],:] *VthroatNew))/(np.sum(VporeNew) + np.sum(VthroatNew))        #SaturationExp = (np.sum(poreAndThroatVolume*(SwExpPore[kk,:])))/(np.sum(poreAndThroatVolume))        #print(VporeNew)        #print(SwPorePNMOF)        out = out + abs(tempSw - SaturationExp[kk])    #'''    #############################################################    #############################################################    #print(out)    return outdef OFOpt(theta):        global tOut1,tOut2,pOut,fExpPore,fExpThroat,originalPath,SectionPart,SectionPartThroat,NN        sName = 'tempFolderOpt'#str(theta)+'_'+str(x[1])+'_'+str(x[0])    if not os.path.exists(sName):        os.mkdir(sName)        #print("Directory " , sName ,  " Created ")    else:            now = datetime.now()        sName = sName + now.strftime("%H:%M:%S")        os.mkdir(sName)        print("Directory " , sName ,  " already exists")        #sPathName = sName+ "/" + sName + ".dat"         #shutil.copy('input_pnflow.dat', sName)        for item in os.listdir(originalPath):        if(item.endswith('.dat')):            shutil.copy(originalPath+item, sName)            #file_path = os.path.join(sName + "/", item)         replaceThetaOn  = False    replaceWeightOn = False        for line in fileinput.FileInput(sName+'/input_pnflow.dat', inplace=1):        if(replaceThetaOn):            #line = line.replace("XX XX", str(theta[0]*180/pi)+ ' '+str(theta[0]*180/pi))            line = line.replace("XX XX", str(theta*180/pi)+ ' '+str(theta*180/pi))            replaceThetaOn = False        elif(replaceWeightOn):            line = line.replace("XX XX", str(x[0]*1.0e9)+ ' '+str(x[1]))            #line = line.replace("XX XX", str(x[0]*15000)+ ' '+str(x[1]*15000))            replaceWeightOn = False                        elif("EQUIL_CON_ANG" in line):            replaceThetaOn = True        elif("PORE_FILL_PRMTR_Fake" in line):            replaceWeightOn = True         sys.stdout.write(line)            a = os.getcwd()    os.chdir(a+"/" + sName)    cmd = os.system("pnflow_tom input_pnflow.dat >/dev/null 2>&1")            os.chdir(a)    pnflowResultsFolderName = 'input_pnflow_res'    basePath                = sName + '/'        poreVolume = pOut[1,:]    poreRadius = pOut[2,:]    throatRadius = tOut1[3,:]    throatVolume = tOut2[6,:]        NumberOfPores = len(poreRadius);    NumberOfThroats= len(throatRadius);        totalPoreVolume = np.sum(poreVolume);    totalThroatVolume = np.sum(throatVolume);        PNMbasePath = basePath + pnflowResultsFolderName+"/";    vtuCounter = len(glob.glob1(PNMbasePath,"*.vtu"))    #print("Addres = ",PNMbasePath)    #print("number of PNM vtu files = ", vtuCounter)    fFazPore = np.zeros((vtuCounter, NumberOfPores))    fFazThroat = np.zeros((vtuCounter, NumberOfThroats))      fileNumber = np.zeros((vtuCounter,2))    nfnf = 0    keyWord0 = 'ffaz'    averageOilOccupancy = np.zeros((vtuCounter, 1));    #print("pore Voume = ", np.sum(poreVolume),"throat Voume = ", np.sum(throatVolume))    with os.scandir(PNMbasePath) as entries:        for entry in entries:            if entry.is_file():                if entry.name.endswith(".vtu") & entry.name.startswith("2_WInj"):                    fFazPore[nfnf,:] = readKeywordInFile(keyWord0,SectionPart,1,NumberOfPores,PNMbasePath+entry.name)-1                    fFazThroat[nfnf,:] = readKeywordInFile(keyWord0,SectionPart,NumberOfPores+2,NumberOfThroats,PNMbasePath+entry.name)-1                                        tempPoreFill = np.sum(poreVolume*(1-fFazPore[nfnf,:]))                     tempThroatFill = np.sum(throatVolume*(1-fFazThroat[nfnf,:]))                     averageOilOccupancy[nfnf,0] = (tempPoreFill+tempThroatFill)/(totalPoreVolume+totalThroatVolume)#(np.sum(poreVolume*fFazPore[nfnf,:])+np.sum(throatVolume*fFazThroat))/(np.sum(poreVolume)+np.sum(throatVolume))                    nfnf = nfnf + 1    #mat_sort = fileNumber[fileNumber[:,1].argsort()[::-1]]    poreOilOccupancyAD = np.zeros((NN,vtuCounter))    throatOilOccupancyAD = np.zeros((NN,vtuCounter))    poreOilOccupancyAAD = np.zeros((NN,vtuCounter))    throatOilOccupancyAAD = np.zeros((NN,vtuCounter))    print('fExpPore',np.shape(fExpPore))    print('fExpThroat',np.shape(fExpThroat))    print('fFazPore',np.shape(fFazPore))    print('fFazThroat',np.shape(fFazThroat))        for ii in range(NN):        for jj in range(nfnf):            poreOilOccupancyAD[ii,jj] = np.sum(poreVolume*(fFazPore[jj,:]-fExpPore[ii,:]))            throatOilOccupancyAD[ii,jj] = np.sum(throatVolume*(fFazThroat[jj,:]-fExpThroat[ii,:]))            poreOilOccupancyAAD[ii,jj] = np.sum(poreVolume*np.absolute(fFazPore[jj,:]-fExpPore[ii,:]))            throatOilOccupancyAAD[ii,jj] = np.sum(throatVolume*np.absolute(fFazThroat[jj,:]-fExpThroat[ii,:]))    #AD = np.zeros((NN,vtuCounter))    #AAD = np.zeros((NN,vtuCounter))    AD  = (poreOilOccupancyAD[:,:nfnf]+throatOilOccupancyAD[:,:nfnf])/(totalPoreVolume+totalThroatVolume)    AAD = (poreOilOccupancyAAD[:,:nfnf]+throatOilOccupancyAAD[:,:nfnf])/(totalPoreVolume+totalThroatVolume)    AADVector = np.zeros(NN)    ADVector = np.zeros(NN)    OccupancyExp = np.zeros(NN)    tempIndex = [0]*NN;    for kk in range(NN):               tempIndex[kk] = np.abs(AD[kk,:] - 0.0).argmin()        ADVector[kk] = AD[kk,tempIndex[kk]]        AADVector[kk]  = AAD[kk,tempIndex[kk]]        OccupancyExp[kk] = 1-(np.sum(poreVolume*(fExpPore[kk,:]))+np.sum(throatVolume*fExpThroat[kk,:]))/(totalPoreVolume+totalThroatVolume)            shutil.rmtree(sName)      #print('file',sName,'removed!')    #print(AADVector)    return sum(AADVector)#(x[0]-y[0])**2 + (x[1]-y[1])**2+ (theta-y[2])**2def OFSA(i,theta,cmdVector,outDiff,outFinal,outArea,ErrCalcMethod = 'V'):        global tOut1,tOut2,pOut,fExpPore,fExpThroat,originalPath,SectionPart,SectionPartThroat,NN        sName = 'tempFolderSA'+ str(i)#+'_'+str(x[1])+'_'+str(x[0])    if not os.path.exists(sName):        os.mkdir(sName)        #print("Directory " , sName ,  " Created ")    else:            now = datetime.now()        sName = sName + now.strftime("%H:%M:%S")        os.mkdir(sName)        print("Directory " , sName ,  " already exists")        #sPathName = sName+ "/" + sName + ".dat"         #shutil.copy('input_pnflow.dat', sName)    print("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz")    print(originalPath)    print("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz")        for item in os.listdir(originalPath):        if(item.endswith('.dat')):            shutil.copy(originalPath+item, sName)            #file_path = os.path.join(sName + "/", item)         replaceThetaOn  = False    replaceWeightOn = False        for line in fileinput.FileInput(sName+'/input_pnflow.dat', inplace=1):        if(replaceThetaOn):            #line = line.replace("XX XX", str(theta[0]*180/pi)+ ' '+str(theta[0]*180/pi))            line = line.replace("XX XX", str(theta*180/pi)+ ' '+str(theta*180/pi))            replaceThetaOn = False        elif(replaceWeightOn):            line = line.replace("XX XX", str(x[0]*1.0e9)+ ' '+str(x[1]))            #line = line.replace("XX XX", str(x[0]*15000)+ ' '+str(x[1]*15000))            replaceWeightOn = False                        elif("EQUIL_CON_ANG" in line):            replaceThetaOn = True        elif("PORE_FILL_PRMTR_Fake" in line):            replaceWeightOn = True         sys.stdout.write(line)            a = os.getcwd()    os.chdir(a+"/" + sName)    #cmd = os.system("pnflow_tom input_pnflow.dat >/dev/null 2>&1")    #xTemp = 'cmd'+str(i)    #exec("%s = %d" % (xTemp,1))    pnflowResultsFolderName = 'input_pnflow_res'    basePath                = sName + '/'    vtuCounter = 0    while(vtuCounter<3):#cmdVector[i]>0):        cmdVector[i] = os.system("pnflow_tom input_pnflow.dat >/dev/null 2>&1")        PNMbasePath = basePath + pnflowResultsFolderName+"/";        vtuCounter = len(glob.glob1(pnflowResultsFolderName+"/","*.vtu"))        #cmdVector[i] = os.system("pnflow_tom input_pnflow.dat >/dev/null 2>&1") #")#        #print('i = ', i, 'outPut = ',cmdVector[i])        print("I am inside...")        print(cmdVector[i])    os.chdir(a)    NumberOfPores = len(pOut[2,:]);    NumberOfThroats= len(tOut1[3,:]);    if(ErrCalcMethod == 'F'):        poreVolume = np.ones(NumberOfPores)        throatVolume = np.ones(NumberOfThroats)    elif(ErrCalcMethod == 'V'):        poreVolume = pOut[1,:]        throatVolume = tOut2[6,:]        poreRadius = pOut[2,:]    throatRadius = tOut1[3,:]        poreVolumeSw = pOut[1,:]    throatVolumeSw = tOut2[6,:]        totalPoreVolume = np.sum(poreVolume);    totalThroatVolume = np.sum(throatVolume);    totalPoreVolumeSw = np.sum(poreVolumeSw);    totalThroatVolumeSw = np.sum(throatVolumeSw);        #print("Addres = ",PNMbasePath)    #print("number of PNM vtu files = ", vtuCounter)    fFazPore = np.zeros((vtuCounter, NumberOfPores))    fFazThroat = np.zeros((vtuCounter, NumberOfThroats))      fileNumber = np.zeros((vtuCounter,2))    nfnf = 0    keyWord0 = 'ffaz'    averageOilOccupancy = np.zeros((vtuCounter, 1));    #print("pore Voume = ", np.sum(poreVolume),"throat Voume = ", np.sum(throatVolume))    with os.scandir(PNMbasePath) as entries:        for entry in entries:            if entry.is_file():                if entry.name.endswith(".vtu") & entry.name.startswith("2_WInj"):                    fFazPore[nfnf,:] = readKeywordInFile(keyWord0,SectionPart,1,NumberOfPores,PNMbasePath+entry.name)-1                    fFazThroat[nfnf,:] = readKeywordInFile(keyWord0,SectionPart,NumberOfPores+2,NumberOfThroats,PNMbasePath+entry.name)-1                                        tempPoreFill = np.sum(poreVolume*(1-fFazPore[nfnf,:]))                     tempThroatFill = np.sum(throatVolume*(1-fFazThroat[nfnf,:]))                     averageOilOccupancy[nfnf,0] = (tempPoreFill+tempThroatFill)/(totalPoreVolume+totalThroatVolume)#(np.sum(poreVolume*fFazPore[nfnf,:])+np.sum(throatVolume*fFazThroat))/(np.sum(poreVolume)+np.sum(throatVolume))                    nfnf = nfnf + 1    #mat_sort = fileNumber[fileNumber[:,1].argsort()[::-1]]    poreOilOccupancyAD = np.zeros((NN,vtuCounter))    throatOilOccupancyAD = np.zeros((NN,vtuCounter))    poreOilOccupancyAAD = np.zeros((NN,vtuCounter))    throatOilOccupancyAAD = np.zeros((NN,vtuCounter))    print('fExpPore',np.shape(fExpPore))    print('fExpThroat',np.shape(fExpThroat))    print('fFazPore',np.shape(fFazPore))    print('fFazThroat',np.shape(fFazThroat))        for ii in range(NN):        for jj in range(nfnf):            poreOilOccupancyAD[ii,jj] = np.sum(poreVolumeSw*(fFazPore[jj,:]-fExpPore[ii,:]))            throatOilOccupancyAD[ii,jj] = np.sum(throatVolumeSw*(fFazThroat[jj,:]-fExpThroat[ii,:]))            poreOilOccupancyAAD[ii,jj] = np.sum(poreVolume*np.absolute(fFazPore[jj,:]-fExpPore[ii,:]))            throatOilOccupancyAAD[ii,jj] = np.sum(throatVolume*np.absolute(fFazThroat[jj,:]-fExpThroat[ii,:]))    #AD = np.zeros((NN,vtuCounter))    #AAD = np.zeros((NN,vtuCounter))    AD  = (poreOilOccupancyAD[:,:nfnf]+throatOilOccupancyAD[:,:nfnf])/(totalPoreVolumeSw+totalThroatVolumeSw)    AAD = (poreOilOccupancyAAD[:,:nfnf]+throatOilOccupancyAAD[:,:nfnf])/(totalPoreVolume+totalThroatVolume)    AADVector = np.zeros(NN)    ADVector = np.zeros(NN)    OccupancyExp = np.zeros(NN)    OccupancyPNM = np.zeros(NN)    tempIndex = [0]*NN;    for kk in range(NN):               tempIndex[kk] = np.abs(AD[kk,:] - 0.0).argmin()        ADVector[kk] = AD[kk,tempIndex[kk]]        AADVector[kk]  = AAD[kk,tempIndex[kk]]        OccupancyExp[kk] = 1-(np.sum(poreVolumeSw*(fExpPore[kk,:]))+np.sum(throatVolumeSw*fExpThroat[kk,:]))/(totalPoreVolumeSw+totalThroatVolumeSw)        OccupancyPNM[kk] = 1-(np.sum(poreVolumeSw*(fFazPore[tempIndex[kk],:]))+np.sum(throatVolumeSw*fFazThroat[tempIndex[kk],:]))/(totalPoreVolumeSw+totalThroatVolumeSw)        shutil.rmtree(sName)      #print('file',sName,'removed!')    #print(AADVector)    print("OOOOOOOOOOOOOOOOOOOOOOOOOOOOO")    print('AADVector', AADVector)    print('OccupancyExp', OccupancyExp)    print("OOOOOOOOOOOOOOOOOOOOOOOOOOOOO")    tempY = (AADVector[0:NN-1]+AADVector[1:NN])/2.0#[(a + b) / 2 for a, b in zip(AADVector[:NN-1:], AADVector[1::])]    tempX = np.diff(OccupancyExp)    outFinal[i] = AADVector[NN-1]    outDiff[i]  = ADVector[NN-1]    outArea[i]  = sum(tempY*tempX)    return sum(AADVector)#(x[0]-y[0])**2 + (x[1]-y[1])**2+ (theta-y[2])**2def OFHM(x):        global tOut1,tOut2,pOut,fExpPore,fExpThroat,originalPath,SectionPart,SectionPartThroat,NN        sName = 'tempFolderHM'#+'_'+str(x[1])+'_'+str(x[0])    if not os.path.exists(sName):        os.mkdir(sName)        #print("Directory " , sName ,  " Created ")    else:            now = datetime.now()        sName = sName + now.strftime("%H:%M:%S")        os.mkdir(sName)        print("Directory " , sName ,  " already exists")        #sPathName = sName+ "/" + sName + ".dat"         #shutil.copy('input_pnflow.dat', sName)      for item in os.listdir(originalPath):        if(item.endswith('.dat')):            shutil.copy(originalPath+item, sName)            #file_path = os.path.join(sName + "/", item)         replaceThetaOn  = False    replaceWeightOn = False    replaceSwImbibitionFinal = False    for line in fileinput.FileInput(sName+'/input_pnflow.dat', inplace=1):        tempString = line.split()        if(replaceThetaOn):            line = line.replace("XX XX", str(theta*180/pi - 10.0)+ ' '+str(theta*180/pi + 10.0))            replaceThetaOn = False        elif(replaceWeightOn):                        #line = line.replace("XX XX", str(x[0]*1.0e9)+ ' '+str(x[1]))            line = line.replace("XX XX", str(x[0]*15000)+ ' '+str(x[1]*15000))            replaceWeightOn = False        elif(replaceSwImbibitionFinal and tempString[0]=='XX'):            line = line.replace("XX", str(x))            replaceSwImbibitionFinal = False        elif("EQUIL_CON_ANG_FAKE" in line):            replaceThetaOn = True        #elif("PORE_FILL_PRMTR" in line):        elif("PORE_FILL_WGT_FAKE" in line):                        replaceWeightOn = True        elif("SAT_CONTROL" in line):            replaceSwImbibitionFinal = True                    sys.stdout.write(line)            a = os.getcwd()    os.chdir(a+"/" + sName)    #cmd = os.system("pnflow_tom input_pnflow.dat >/dev/null 2>&1")    #xTemp = 'cmd'+str(i)    #exec("%s = %d" % (xTemp,1))    pnflowResultsFolderName = 'input_pnflow_res'    basePath                = sName + '/'    vtuCounter = 0    while(vtuCounter<3):#cmdVector[i]>0):        cmd = os.system("pnflow_tom input_pnflow.dat >/dev/null 2>&1")        PNMbasePath = basePath + pnflowResultsFolderName+"/";        vtuCounter = len(glob.glob1(pnflowResultsFolderName+"/","*.vtu"))        #cmdVector[i] = os.system("pnflow_tom input_pnflow.dat >/dev/null 2>&1") #")#        #print('i = ', i, 'outPut = ',cmdVector[i])    os.chdir(a)    return sName#############def checkError(folderName):    global fPNMPore_HM,fPNMThroat_HM    pnflowResultsFolderName = 'input_pnflow_res'    basePath                = folderName + '/'        poreVolume = pOut[1,:]    poreRadius = pOut[2,:]    throatRadius = tOut1[3,:]    throatVolume = tOut2[6,:]        NumberOfPores = len(poreRadius);    NumberOfThroats= len(throatRadius);        totalPoreVolume = np.sum(poreVolume);    totalThroatVolume = np.sum(throatVolume);        PNMbasePath = basePath + pnflowResultsFolderName    #print(PNMbasePath+'/*.vtu')    list_of_files = glob.glob(PNMbasePath+'/*.vtu') # * means all if need specific format then *.csv    #print(list_of_files)    latest_file = max(list_of_files, key=os.path.getctime)    print(latest_file)      vtuCounter = 1    #print("Addres = ",PNMbasePath)    #print("number of PNM vtu files = ", vtuCounter)    fFazPore = np.zeros((vtuCounter, NumberOfPores))    fFazThroat = np.zeros((vtuCounter, NumberOfThroats))      fileNumber = np.zeros((vtuCounter,2))    nfnf = 0    keyWord0 = 'ffaz'    #averageOilOccupancy = np.zeros((vtuCounter, 1));    #mat_sort = fileNumber[fileNumber[:,1].argsort()[::-1]]    fFazPore[0,:] = readKeywordInFile(keyWord0,SectionPart,1,NumberOfPores,latest_file)-1    fFazThroat[0,:] = readKeywordInFile(keyWord0,SectionPart,NumberOfPores+2,NumberOfThroats,latest_file)-1       tempPoreFill = np.sum(poreVolume*(1-fFazPore[0,:]))     tempThroatFill = np.sum(throatVolume*(1-fFazThroat[0,:]))     averageOilOccupancy = (tempPoreFill+tempThroatFill)/(totalPoreVolume+totalThroatVolume)#(np.sum(poreVolume*fFazPore[nfnf,:])+np.sum(throatVolume*fFazThroat))/(np.sum(poreVolume)+np.sum(throatVolume))    poreOilOccupancyAD = np.sum(poreVolume*(fFazPore[0,:]-fExpPore_HM))    throatOilOccupancyAD = np.sum(throatVolume*(fFazThroat[0,:]-fExpThroat_HM))    poreOilOccupancyAAD = np.sum(poreVolume*np.absolute(fFazPore[0,:]-fExpPore_HM))    throatOilOccupancyAAD = np.sum(throatVolume*np.absolute(fFazThroat[0,:]-fExpThroat_HM))        #AD = np.zeros((NN,vtuCounter))    #AAD = np.zeros((NN,vtuCounter))    AD  = (poreOilOccupancyAD+throatOilOccupancyAD)/(totalPoreVolume+totalThroatVolume)    AAD = (poreOilOccupancyAAD+throatOilOccupancyAAD)/(totalPoreVolume+totalThroatVolume)    print("===============")    print(AAD)    print("===============")    fPNMPore_HM = fFazPore[0,:]    fPNMThroat_HM = fFazThroat[0,:]    return AD,AAD############################################################################################                                  Remove Reqrrangment:                               ############################################################################################def unifyOccupancy(aM):    temp = np.zeros(np.shape(aM))    m = np.shape(aM)[0]    for ii in range(m):        temp[ii,:] = np.amax(aM[ii:,:], axis=0)    return temp############################################################################################                                  Update Contact angle:                               ############################################################################################def UpdateContactAngle(dtheta,thetaMax):    thetaPore = np.loadtxt(originalPath+'CAFile_pores.dat')    thetaThroat = np.loadtxt(originalPath+'CAFile_throats.dat')    pCA_Old = thetaPore    tCA_Old = thetaThroat    thetaPore   = thetaPore   + (fExpPore_HM   - fPNMPore_HM)*dtheta    thetaThroat = thetaThroat + (fExpThroat_HM - fPNMThroat_HM)*dtheta    thetaPore[thetaPore>thetaMax] = thetaMax    thetaPore[thetaPore<0.0] = 0.0    thetaThroat[thetaThroat>thetaMax] = thetaMax    thetaThroat[thetaThroat<0.0] = 0.0    if(((sum(abs(pCA_Old-thetaPore)))+(sum(abs(tCA_Old-thetaThroat))))<dtheta):        thetaPore = thetaPore+0.1*(np.random.random(np.shape(thetaPore))-0.5)        thetaThroat = thetaThroat+0.1*(np.random.random(np.shape(thetaThroat))-0.5)        dtheta      = 0.9 * dtheta    thetaPore[thetaPore>thetaMax] = thetaMax    thetaPore[thetaPore<0.0] = 0.0    thetaThroat[thetaThroat>thetaMax] = thetaMax    thetaThroat[thetaThroat<0.0] = 0.0    np.savetxt(originalPath+'CAFile_pores.dat',thetaPore,fmt='%.2f')    np.savetxt(originalPath+'CAFile_throats.dat',thetaThroat,fmt='%.2f')    return dtheta############################################################################################                                  Get Image Occuoancy:                               ############################################################################################def getMeanOccupancyFromImage(i):    ##    #global fExpPore,fExpThroat,pOut,tOut2    #global     global fExpPore,fExpThroat,pOut,tOut1,tOut2,pOut,SwExpPore,throatFraction,fExpPore_HM, fExpThroat_HM    unified_fExpPore = unifyOccupancy(fExpPore)    unified_fExpThroat = unifyOccupancy(fExpThroat)    fExpPore_HM = unified_fExpPore[i,:]    fExpThroat_HM = unified_fExpThroat[i,:]     poreVolume = pOut[1,:]    poreVolumeSw = pOut[1,:]    throatVolume = tOut2[6,:]    throatVolumeSw = tOut2[6,:]    NumberOfPores = len(pOut[2,:]);    NumberOfThroats= len(tOut1[3,:]);    tempSw = 1- (np.sum(fExpPore[i,:]*poreVolume)+np.sum(fExpThroat[i,:]*throatVolume))/(np.sum(poreVolume)+np.sum(throatVolume))    return tempSw############################################################################################                                  Get Image Saturation:                               ############################################################################################def getSwFromImage(i):#    '''    global fExpPore,fExpThroat,pOut,tOut1,tOut2,pOut,SwExpPore,throatFraction,fExpPore_HM, fExpThroat_HM    fExpPore_HM = fExpPore[i,:]    fExpThroat_HM = fExpThroat[i,:]     poreVolume = pOut[1,:]    poreVolumeSw = pOut[1,:]    throatVolume = tOut2[6,:]    throatVolumeSw = tOut2[6,:]    NumberOfPores = len(pOut[2,:]);    NumberOfThroats= len(tOut1[3,:]);    poreAndThroatVolume = np.zeros((NumberOfPores))    vTemp = min(poreVolume[poreVolume>0])    poreVolume[poreVolume==0]=0.5*vTemp    vTemp = min(poreVolumeSw[poreVolumeSw>0])    poreVolumeSw[poreVolumeSw==0]=0.5*vTemp    vTemp = min(throatVolume[throatVolume>0])    throatVolume[throatVolume==0]=0.5*vTemp    vTemp = min(throatVolumeSw[throatVolumeSw>0])    throatVolumeSw[throatVolumeSw==0]=0.5*vTemp    for j in range(NumberOfThroats):        pi = tOut1[1,j].astype(int)-1        pj = tOut1[2,j].astype(int)-1        poreAndThroatVolume[pi] = poreAndThroatVolume[pi] + throatFraction[0,j]*throatVolume[j]        poreAndThroatVolume[pj] = poreAndThroatVolume[pj] + throatFraction[1,j]*throatVolume[j]    poreAndThroatVolume = poreAndThroatVolume+poreVolumeSw    print(np.shape(SwExpPore))    tempSw = np.sum(SwExpPore[i,:]*poreAndThroatVolume)/np.sum(poreAndThroatVolume)    return tempSw#    '''def getSwFromImage2(i):    ######################    global fExpPore,fExpThroat,pOut,tOut1,tOut2,pOut,SwExpPore,throatFraction,fExpPore_HM, fExpThroat_HM    fExpPore_HM = fExpPore[i,:]    fExpThroat_HM = fExpThroat[i,:]     poreVolume = pOut[1,:]    poreVolumeSw = pOut[1,:]    throatVolume = tOut2[6,:]    throatVolumeSw = tOut2[6,:]    NumberOfPores = len(pOut[2,:]);    NumberOfThroats= len(tOut1[3,:]);    #tempSw1 = 1- (np.sum(fExpPore_HM*poreVolume)+np.sum(fExpThroat_HM*throatVolume))/(np.sum(poreVolume)+np.sum(throatVolume))    #'''    poreAndThroatVolume = np.zeros((NumberOfPores))    vTemp = min(poreVolume[poreVolume>0])    poreVolume[poreVolume==0]=0.5*vTemp    vTemp = min(poreVolumeSw[poreVolumeSw>0])    poreVolumeSw[poreVolumeSw==0]=0.5*vTemp    vTemp = min(throatVolume[throatVolume>0])    throatVolume[throatVolume==0]=0.5*vTemp    vTemp = min(throatVolumeSw[throatVolumeSw>0])    throatVolumeSw[throatVolumeSw==0]=0.5*vTemp    for j in range(NumberOfThroats):        pi = tOut1[1,j].astype(int)-1        pj = tOut1[2,j].astype(int)-1        poreAndThroatVolume[pi] = poreAndThroatVolume[pi] + throatFraction[0,j]*throatVolume[j]        poreAndThroatVolume[pj] = poreAndThroatVolume[pj] + throatFraction[1,j]*throatVolume[j]    poreAndThroatVolume = poreAndThroatVolume+poreVolumeSw    #######################    tempSw = np.array([0.04, 0.39,0.42,0.46,0.47,0.52,0.57])    return tempSw[i]def typeSwIF():    SwInitial = getSwFromImage(0)    print('SwInitial = ',SwInitial)    m = np.shape(fExpPore)[0]    SwFinal = getSwFromImage(m-1)    print('SwFinal = ',SwFinal)    for jj in range(m):        print("phi ",jj, ' = ',getSwFromImage(jj))        print("phi ",jj, ' = ',getMeanOccupancyFromImage(jj))    #######################def runHistoryMatch(InitIndex,dTheta0=1,maxCA = 180,ErrorCriteria = 0.04,maxCounter = 100):        #######################    SwInitial = getSwFromImage(0)#getMeanOccupancyFromImage(0)#    print('SwInitial = ',SwInitial)    m = np.shape(fExpPore)[0]    SwFinal = getSwFromImage(m-1)#getMeanOccupancyFromImage(m-1)#    print('SwFinal = ',SwFinal)    #######################    poreCA0 = poreCA    throatCA0 = throatCA    i = InitIndex    InitIndex2 = InitIndex    SwPre = SwInitial    Sw = SwInitial    while i < m:        oldError = 1.0        SwPre = Sw        Sw = getSwFromImage(i)#getMeanOccupancyFromImage(i)#        dTheta = dTheta0        myIterator = 0        if(SwInitial>=(Sw-0.01) or (Sw<SwPre)):            i+=1            continue        while(1):            print('Index = ', i, 'Sw = ',Sw)            tempName = OFHM(Sw)            out1,out2 = checkError(tempName)            shutil.rmtree(tempName)                        #break            #'''            if((myIterator+1)%10 ==0):                #i = InitIndex2                print("myIterator = ", myIterator)                if((out2-oldError)>-0.00025):                    poreCA[((fExpPore_HM   + fPNMPore_HM)==1)]=47.8                    throatCA[((fExpThroat_HM   + fPNMThroat_HM)==1)]=47.8                    i+=1                    poreCA[((fExpPore_HM   + fPNMPore_HM)==1)]=47.8                    throatCA[((fExpThroat_HM   + fPNMThroat_HM)==1)]=47.8                    break                oldError = out2            if ((out2<ErrorCriteria) or myIterator>maxCounter):                if(myIterator == 0):                    dTheta = UpdateContactAngle(0.5*dTheta,maxCA)                    InitIndex2 = i                i+=1                poreCA[((fExpPore_HM   + fPNMPore_HM)==1)]=47.8                throatCA[((fExpThroat_HM   + fPNMThroat_HM)==1)]=47.8                break            dTheta = UpdateContactAngle(dTheta,maxCA)            #dTheta = 3.0*dTheta/4.0            myIterator=myIterator+1            #'''#############def OFCall(originalPath,x):    sName = "TempFolder"+str(x)    if not os.path.exists(sName):        os.mkdir(sName)        #print("Directory " , sName ,  " Created ")    else:            now = datetime.now()        sName = sName + now.strftime("%H:%M:%S")        os.mkdir(sName)        print("Directory " , sName ,  " already exists")        sPathName = sName+ "/" + sName + ".dat"         print(sName)        #shutil.copy('input_pnflow.dat', sName)       for item in os.listdir(originalPath):        if(item.endswith('.dat')):            shutil.copy(originalPath+item, sName)    replaceThetaOn  = False    replaceWeightOn = False    replaceSwImbibitionFinal = False    for line in fileinput.FileInput(sName+'/input_pnflow.dat', inplace=1):        tempString = line.split()        if(replaceThetaOn):            line = line.replace("XX XX", str(x*180/pi)+ ' '+str(x*180/pi))            replaceThetaOn = False        elif(replaceWeightOn):                        #line = line.replace("XX XX", str(x[0]*1.0e9)+ ' '+str(x[1]))            line = line.replace("XX XX", str(x[0]*15000)+ ' '+str(x[1]*15000))            replaceWeightOn = False        elif(replaceSwImbibitionFinal and tempString[0]=='XX'):            line = line.replace("XX", str(x))            replaceSwImbibitionFinal = False        elif("EQUIL_CON_ANG" in line):            replaceThetaOn = True        #elif("PORE_FILL_PRMTR" in line):        elif("PORE_FILL_WGT_FAKE" in line):                        replaceWeightOn = True        elif("SAT_CONTROL_Fake" in line):            replaceSwImbibitionFinal = True                    sys.stdout.write(line)    thetaPoreCorr = np.loadtxt(sName+'/cCAFile_pores.dat')    thetaThroatCorr = np.loadtxt(sName+'/cCAFile_throats.dat')    np.random.seed(x)    rndPore = np.random.permutation(len(thetaPoreCorr))    print(rndPore)    rndThroat = np.random.permutation(len(thetaThroatCorr))    os.remove(sName+'/CAFile_pores.dat')    os.remove(sName+'/CAFile_throats.dat')    thetaPoreCorr=thetaPoreCorr[rndPore]    thetaThroatCorr=thetaThroatCorr[rndThroat]    np.savetxt(sName+'/CAFile_pores.dat',thetaPoreCorr,fmt='%.2f')    np.savetxt(sName+'/CAFile_throats.dat',thetaThroatCorr,fmt='%.2f')        a = os.getcwd()    os.chdir(a+"/" + sName)    cmd = os.system("pnflow_tom input_pnflow.dat >/dev/null 2>&1") #")#    while(cmd>0):        cmd = os.system("pnflow_tom input_pnflow.dat >/dev/null 2>&1") #")#        print("I am inside...")    #subprocess.call('pnflow_tom input_pnflow.dat >/dev/null 2>&1')    os.chdir(a)    pnflowResultsFolderName = 'input_pnflow_res'    basePath                = sName + '/'############################################################################################                                  Plot Distribution:                                  ############################################################################################def plotDistribution(radiusData,weights,fFaz,linePattern,LineWidth,n):        vTotal = np.sum(weights);    rMax = np.max(radiusData)+1e-32;    #print("ZZZZZZZZZZZZZZZZZZ")    #print("rMax",rMax)    #print("ZZZZZZZZZZZZZZZZZZ")    rMin = np.min(radiusData)-1e-32;    drV   = (rMax-rMin)/(n-1);    Edges = np.zeros(shape=(n,1), dtype = float)       fr = np.zeros(shape=(n-1,1), dtype = float)    Edges[0]=rMin;        tempArray = (radiusData * fFaz)    for ii in range(n-1):                rUpper = rMin+(ii+1)*drV;        rLower = rMin+(ii)*drV;        Edges[ii+1]= rUpper;        if(ii==n-2):            rUpper=np.inf        #if(ii==0):            #rLower=-np.inf        temp = ((tempArray >= rLower) & (tempArray < rUpper));        #        print("=========================")#        print(temp)        #        print(weights[temp])#        print("=========================")                fr[ii] = np.sum(weights[temp]);            rV = Edges[:n-1]+np.diff(Edges,axis=0)/2;    minrV = min(rV)    #if(insertZero):    rV = np.insert(rV, 0 ,0.0)    fr = np.insert(fr, 0 ,0.0)        xx = rV*1e6    yy = fr/(vTotal);    if(minrV*1e6>10):        xx[0] = minrV*1e6-0.00001#    print("y = ",sum(yy))     plt.plot(xx,yy,linePattern,linewidth=LineWidth)    #plt.show        return xx,yydef plotPoreAndThroatDist(fileName,nBin,DistType='V'):    print('Inside pore and throat plot!')    if(DistType=='V'):        poreVolume = pOut[1,:]        throatVolume = tOut2[6,:]    elif(DistType=='F'):        poreVolume = np.ones(len(pOut[1,:]))        throatVolume = np.ones(len(tOut2[6,:]))    poreRadius = pOut[2,:]    throatRadius = tOut1[3,:]    porePhaseChange = np.diff(fExpPore,axis=0)    throatPhaseChange = np.diff(fExpThroat,axis=0)    binNumber = nBin    nPlot = -1    ##########################################################################################    ##                         Plot pore filling distributions                              ##    ##########################################################################################    plt.figure(2*(nPlot+1))    x,y = plotDistribution(poreRadius,poreVolume,np.ones(len(poreRadius)),'silver',4,binNumber)    plt.fill_between(x,0,y,color='silver', label='_nolegend_')    poreRadiusMaximimLimit = np.max(x)    plt.xlim([np.min(x), poreRadiusMaximimLimit])    plt.ylim([np.min(y), np.max(y)*1.1])    plt.xlabel('Radius (${\mu}m$)');    plt.ylabel('Probability')    plt.title('Pore size distribution')    if os.path.exists(fileName+"_pores"+DistType+str(nPlot)+".png"):        os.remove(fileName+"_pores"+DistType+str(nPlot)+".png")            plt.savefig(fileName+"_pores"+DistType+str(nPlot)+".png")    ##################                  Plot Data                     #################    #'''    ##########################################################################################    ##                         Plot throat filling distributions                            ##    ##########################################################################################    plt.figure(2*(nPlot+1)+1)    x,y = plotDistribution(throatRadius,throatVolume,np.ones(len(throatRadius)),'silver',4,binNumber)    plt.fill_between(x,0,y,color='silver', label='_nolegend_')    plt.xlim([np.min(x), poreRadiusMaximimLimit])    plt.ylim([np.min(y), np.max(y)*1.1])    plt.xlabel('Radius (${\mu}m$)');    plt.ylabel('Probability')    plt.title('Throat size distribution')    if os.path.exists(fileName+"_throats"+DistType+str(nPlot)+".png"):        os.remove(fileName+"_throats"+DistType+str(nPlot)+".png")            plt.savefig(fileName+"_throats"+DistType+str(nPlot)+".png")   def plotCAngleDistribution(fileName,thetaThermo,nBin=41,DistType='V'):    #fExpPore,fExpThroat,fFazPore,fFazThroat    poreMaskW = ((1-fFazPore[np.max(tempIndex),:])*(1-fExpPore[-1,:]))    poreMaskO = ((fFazPore[np.max(tempIndex),:])*(fExpPore[-1,:]))    temppCA    =  (poreCA-thetaThermo) > 0.2    poreMask = (poreMaskW + poreMaskO*temppCA)>0.5#==fFazPore[np.max(tempIndex),:]))>0.5    #poreMask = (poreMaskW)>0.5    plt.figure(100)    poreRadius = pOut[2,:]    x = poreRadius[poreMask]    y = poreCA[poreMask]    plt.plot(x*1.0e6, y, '.',  markersize=2, color='black', alpha=0.025)    plt.xlabel('Pore radius (${\mu m}$)', fontsize = 16)    plt.ylabel('Contact angle (°)', fontsize = 16)    plt.title('Contact angle vs pore radius')    if os.path.exists(fileName+"_rvsCA_pores.png"):        os.remove(fileName+"_rvsCA_pores.png")            plt.savefig(fileName+"_rvsCA_pores.png",dpi = 300)        print("Exp.",fExpPore)    print(np.sum(fExpPore[-1,:]))    print("PNM",fFazPore[np.max(tempIndex),:])    print("Mask",poreMask)    print(poreCA)    throatMaskW = ((1-fFazThroat[np.max(tempIndex),:])*(1-fExpThroat[-1,:]))#>0.5#==fFazThroat[np.max(tempIndex),:]))>0.5    throatMaskO = ((fFazThroat[np.max(tempIndex),:])*(fExpThroat[-1,:]))    temptCA    =  (throatCA-thetaThermo) > 0.2    throatMask = (throatMaskW + throatMaskO*temptCA)>0.5    plt.figure(101)    throatRadius = tOut1[3,:]    x = throatRadius[throatMask]    y = throatCA[throatMask]    plt.plot(x*1.0e6, y, '.',  markersize=2, color='black', alpha=0.025)    plt.xlabel('Pore radius (${\mu m}$)', fontsize = 16)    plt.ylabel('Contact angle (°)', fontsize = 16)    plt.title('Contact angle vs pore radius')    if os.path.exists(fileName+"_rvsCA_throats.png"):        os.remove(fileName+"_rvsCA_throats.png")            plt.savefig(fileName+"_rvsCA_throats.png",dpi = 300)    #throatMask = throatMaskW         if(DistType=='V'):        poreVolume = pOut[1,:]        throatVolume = tOut2[6,:]    elif(DistType=='F'):        poreVolume = np.ones(len(pOut[1,:]))        throatVolume = np.ones(len(tOut2[6,:]))    binNumber = nBin    nPlot = 2    poreVolumePrim = poreVolume[poreMask]    throatVolumePrim = throatVolume[throatMask]    ##########################################################################################    ##                         Plot pore filling distributions                              ##    ##########################################################################################    plt.figure(2*(nPlot+1))    x,y = plotDistribution(poreCA[poreMask]*1e-6,poreVolume[poreMask],np.ones(len(poreCA[poreMask])),'silver',4,binNumber)    plt.fill_between(x,0,y,color='silver', label='_nolegend_')    plt.plot([thetaThermo, thetaThermo],[0, 1.0],'r--',linewidth=2)    poreCAMaximimLimit = np.max(x)    #plt.xlim([np.min(x), poreCAMaximimLimit])    plt.xlim([0, 180])    plt.ylim([np.min(y), np.max(y)*1.1])    props = dict(boxstyle='round', facecolor='wheat', alpha=0.5)    plt.text(35, 1.02, '${\Theta}_t$ = 47.8°',bbox=props)    plt.xlabel('Contact angle (°)');    plt.ylabel('Probability')    plt.title('Pore tuning angle distribution')    if os.path.exists(fileName+"_CA_pores"+DistType+str(nPlot)+".png"):        os.remove(fileName+"_CA_pores"+DistType+str(nPlot)+".png")            plt.savefig(fileName+"_CA_pores"+DistType+str(nPlot)+".png")    ##################                  Plot Data                     #################    #'''    ##########################################################################################    ##                         Plot throat filling distributions                            ##    ##########################################################################################    plt.figure(2*(nPlot+1)+1)    x,y = plotDistribution(throatCA[throatMask]*1e-6,throatVolume[throatMask],np.ones(len(throatCA[throatMask])),'silver',4,binNumber)    #print("TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT")    #print("x=",x)    #print("y=",y)    #print("TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT")        plt.fill_between(x,0,y,color='silver', label='_nolegend_')    plt.plot([thetaThermo, thetaThermo],[0, 1.0],'r--',linewidth=2)    #plt.xlim([np.min(x), np.max(x)])    plt.xlim([0, 180])    plt.ylim([np.min(y), np.max(y)*1.1])    plt.xlabel('Contact angle (°)');    plt.ylabel('Probability')    plt.text(35, 1.03, '${\Theta}_t$ = 47.8°',bbox=props)    plt.title('Throat tuning angle distribution')    if os.path.exists(fileName+"_CA_throats"+DistType+str(nPlot)+".png"):        os.remove(fileName+"_CA_throats"+DistType+str(nPlot)+".png")            plt.savefig(fileName+"_CA_throats"+DistType+str(nPlot)+".png")    #poreMask = (fFazPore[np.max(tempIndex),:]!=fExpPore[-1,:])    pCACorrected = poreCA    #pCACorrected[poreMask] = thetaThermo    tCACorrected = throatCA    #throatMask = (fFazThroat[np.max(tempIndex),:]!=fExpThroat[-1,:])    #tCACorrected[throatMask] = thetaThermo    np.savetxt(originalPath+'cCAFile_pores.dat',pCACorrected,fmt='%.2f')    np.savetxt(originalPath+'cCAFile_throats.dat',tCACorrected,fmt='%.2f')    np.savetxt(originalPath+'poreMask.dat',1-fExpPore[-1,:],fmt='%d')    np.savetxt(originalPath+'throatMask.dat',1-fExpThroat[-1,:],fmt='%d')         def plotDistributionError(fileName,nBin=41,DistType='V'):    if(DistType=='V'):        poreVolume = pOut[1,:]        throatVolume = tOut2[6,:]    elif(DistType=='F'):        poreVolume = np.ones(len(pOut[1,:]))        throatVolume = np.ones(len(tOut2[6,:]))    poreRadius = pOut[2,:]    throatRadius = tOut1[3,:]    porePhaseChange = np.diff(fExpPore,axis=0)    throatPhaseChange = np.diff(fExpThroat,axis=0)    binNumber = nBin    nPlot = 1    ##########################################################################################    ##                         Plot pore filling distributions                              ##    ##########################################################################################    plt.rc('font', family='serif')    plt.rcParams['axes.spines.right'] = False    plt.rcParams['axes.spines.top'] = False        #=plt.rc('xtick', labelsize='x-small')    #plt.rc('ytick', labelsize='x-small')    #plt.rc('figure', titlesize='x-small')    #plt.rc('legend', fontsize='x-small')    for nPlot in range(NN-1,NN):#range(0,1):#        plt.figure(2*(nPlot+1),figsize=(4, 3))        x,y = plotDistribution(poreRadius,poreVolume,np.ones(len(poreRadius)),'silver',4,binNumber)        plt.fill_between(x,0,y,color='silver', label='_nolegend_')        poreRadiusMaximimLimit = np.max(x)        plt.xlim([np.min(x), poreRadiusMaximimLimit])        plt.ylim([np.min(y), np.max(y)*1.1])        plotDistribution(poreRadius,poreVolume, 1 - fFazPore[tempIndex[nPlot],:],'g--',1,binNumber)               plotDistribution(poreRadius,poreVolume, 1 - fExpPore[nPlot,:],'b:',1,binNumber)            plotDistribution(poreRadius,poreVolume, abs(fFazPore[tempIndex[nPlot],:] - fExpPore[nPlot,:]),'r-',1,binNumber)         plt.xlabel('Radius (${\mu}m$)');        plt.ylabel('Probability')        plt.legend(['All','Water-filled in model','Water-filled in exp','Wrongly filled overall'],loc='lower left', bbox_to_anchor= (-0.2, 1.02), ncol=2, borderaxespad=0, frameon=False)        plt.text(poreRadiusMaximimLimit*.8,np.max(y)*.5,'Pores')#,fontsize=12)        #plt.title('Pore sizes that are filled with water at the end of waterflooding',size='x-small')        plt.tick_params(direction='in')        if os.path.exists(fileName+"_pores"+DistType+str(nPlot)+".eps"):            os.remove(fileName+"_pores"+DistType+str(nPlot)+".eps")                plt.savefig(fileName+"_pores"+DistType+str(nPlot)+".eps",format='eps', bbox_inches='tight')        if os.path.exists(fileName+"_pores"+DistType+str(nPlot)+".png"):            os.remove(fileName+"_pores"+DistType+str(nPlot)+".png")                plt.savefig(fileName+"_pores"+DistType+str(nPlot)+".png",dpi=300)        ##################                  Plot Data                     #################        #'''        ##########################################################################################        ##                         Plot throat filling distributions                            ##        ##########################################################################################        plt.figure(2*(nPlot+1)+1,figsize=(4, 3))        x,y = plotDistribution(throatRadius,throatVolume,np.ones(len(throatRadius)),'silver',4,binNumber)        plt.fill_between(x,0,y,color='silver', label='_nolegend_')        plt.xlim([np.min(x), poreRadiusMaximimLimit])        plt.ylim([np.min(y), np.max(y)*1.1])        #    plotDistribution(throatRadius,throatVolume,  fExpThroat[ii,:],'--m',2,binNumber)           plotDistribution(throatRadius,throatVolume, 1 - fFazThroat[tempIndex[nPlot],:],'g--',1,binNumber)               plotDistribution(throatRadius,throatVolume, 1 - fExpThroat[nPlot,:],'b:',1,binNumber)        plotDistribution(throatRadius,throatVolume, abs(fExpThroat[nPlot,:] - fFazThroat[tempIndex[nPlot],:]),'r-',1,binNumber)        #plotDistribution(throatRadius,throatVolume, fExpThroat[ii+1,:] - fExpThroat[ii,:],'--r',2,binNumber)            #plotDistribution(throatRadius,throatVolume, (1-fExpThroat[ii+1,:])*(1-fExpThroat[ii,:])+(fExpThroat[ii+1,:])*(fExpThroat[ii,:]),'--g',2,binNumber)            plt.xlabel('Radius (${\mu}m$)');        plt.ylabel('Probability')        plt.legend(['All','Water-filled in model','Water-filled in exp','Wrongly filled overall'],loc='lower left', bbox_to_anchor= (-0.2, 1.02), ncol=2, borderaxespad=0, frameon=False)        plt.text(poreRadiusMaximimLimit*.72,np.max(y)*.5,'Throats')#,fontsize=12)        #plt.title('Throat sizes that are filled with water at the end of waterflooding',size='x-small')        plt.tick_params(direction='in')        if os.path.exists(fileName+"_throats"+DistType+str(nPlot)+".eps"):            os.remove(fileName+"_throats"+DistType+str(nPlot)+".eps")                plt.savefig(fileName+"_throats"+DistType+str(nPlot)+".eps",format='eps', bbox_inches='tight')        if os.path.exists(fileName+"_throats"+DistType+str(nPlot)+".png"):            os.remove(fileName+"_throats"+DistType+str(nPlot)+".png")                plt.savefig(fileName+"_throats"+DistType+str(nPlot)+".png",dpi=300)def plotCorrelationTest(inputAddres,TD,dInput,rInput):    originalPath = inputAddres        with os.scandir(originalPath) as entries:        for entry in entries:            if entry.is_file():                if entry.name.endswith("_link2.dat"):                    temp = np.genfromtxt(originalPath+entry.name, delimiter="", unpack=True)                    throatVolume = temp[6,:]                    NumberOfThroats = len(throatVolume);                    tOut2 = temp;                elif entry.name.endswith("_link1.dat"):                    temp = np.genfromtxt(originalPath+entry.name, delimiter="",skip_header=True, unpack=True)                    throatRadius = temp[3,:]                    throatG      = temp[4,:]                    tOut1 = temp                elif entry.name.endswith("_link3.dat"):                    temp = np.genfromtxt(originalPath+entry.name, delimiter="",skip_header=True, unpack=True)                    temp1 = np.sum(temp[4:,:],axis=0)                    #print(temp1)                    throatFraction = temp[4:,:]/temp1                    throatLocation = temp[1:4,:]                    throatFraction[0,np.isnan(throatFraction[0,:])]=0.5                    throatFraction[1,np.isnan(throatFraction[1,:])]=0.5                    #print('throatFraction0',temp[0,np.isnan(throatFraction[0,:])])                    #print('throatFraction1',temp[0,np.isnan(throatFraction[1,:])])                  elif entry.name.endswith("_node2.dat"):                    temp = np.genfromtxt(originalPath+entry.name, delimiter="", unpack=True)                    poreVolume = temp[1,:]                    poreRadius = temp[2,:]                    poreG      = temp[3,:]                    pOut = temp                    NumberOfPores = len(poreRadius);                elif entry.name.endswith("_node1.dat"):                    f = open(originalPath+entry.name)                    temp = np.loadtxt(f, skiprows=1, usecols=[1,2,3,4])                    #poreLocation = np.loadtxt(f, skiprows=1, usecols=[1])                    #print(temp)                    poreCN = temp[:,3]                    poreLocation = temp[:,0:3]                    #temp = np.loadtxt(f, skiprows=1, usecols=[1])                    #poreLocation[:,1]=temp[:]                    #temp = np.loadtxt(f, skiprows=1, usecols=[2])                    #poreLocation[:,2]=temp[:]                    #temp = np.loadtxt(f, skiprows=1, usecols=[3])                    #poreLocation[:,3]=temp[:]                    f.close()                elif entry.name.startswith("fw"):                    temp = np.genfromtxt(originalPath+entry.name, delimiter="", unpack=True)                    #print(temp)                    fw = temp[:]                    #print("fw = ",fw)                elif entry.name.endswith("CAFile_pores.dat"):                    poreCA = np.loadtxt(originalPath+entry.name)                elif entry.name.endswith("CAFile_throats.dat"):                    throatCA = np.loadtxt(originalPath+entry.name)    maskPoreTD = abs(poreCA-TD)>0.5    maskThroatTD = abs(throatCA-TD)>0.5    plt.figure(1)    x = poreRadius    y = poreCA    plt.plot(x*1.0e6, y, '.',  markersize=2, color='black', alpha=0.025)    plt.xlabel('Pore radius (${\mu m}$)', fontsize = 16)    plt.ylabel('Contact angle (deg)', fontsize = 16)    plt.title('Contact angle vs pore radius')    #print('pore r = ',pearsonr(x, y))    #print('masked pore r = ',pearsonr(x[maskPoreTD], y[maskPoreTD]))        if os.path.exists(inputAddres+"RpCorrelation.png"):        os.remove(inputAddres+"RpCorrelation.png")            plt.savefig(inputAddres+"RpCorrelation.png")    plt.figure(2)    x = throatRadius    y = throatCA    plt.plot(x*1.0e6, y, '.',  markersize=2, color='black', alpha=0.025)    plt.xlabel('Throat radius (${\\mu m}$)', fontsize = 16)    plt.ylabel('Contact angle (°)', fontsize = 16)    plt.title('Contact angle vs throat radius')    #print('throat r = ',pearsonr(x, y))    #print('masked throat r = ',pearsonr(x[maskThroatTD], y[maskThroatTD]))    maskPoreTD2 = abs(poreCA-TD)>14.999999    print('changed p Num = ',1-sum(maskPoreTD2)/NumberOfPores)    #print('changed Vol = ',sum(maskPoreTD2*poreVolume)/sum(poreVolume))    if os.path.exists(inputAddres+"RtCorrelation.png"):        os.remove(inputAddres+"RtCorrelation.png")            plt.savefig(inputAddres+"RtCorrelation.png")    plt.figure(3)    x = poreG    y = poreCA    plt.plot(x, y, '.',  markersize=2, color='black', alpha=0.025)    plt.xlabel('Pore G', fontsize = 16)    plt.ylabel('Contact angle (°)', fontsize = 16)    plt.title('Contact angle vs pore G')        if os.path.exists(inputAddres+"GpCorrelation.png"):        os.remove(inputAddres+"GpCorrelation.png")            plt.savefig(inputAddres+"GpCorrelation.png")    plt.figure(7)    x = poreG    y = poreRadius    plt.plot(x, y*1.0e6, '.',  markersize=2, color='black', alpha=0.025)    plt.xlabel('Pore G', fontsize = 16)    plt.ylabel('Pore radius (${\\mu m}$)', fontsize = 16)    plt.title('Pore radius vs Pore G')    if os.path.exists(inputAddres+"rvsGpCorrelation.png"):        os.remove(inputAddres+"rvsGpCorrelation.png")            plt.savefig(inputAddres+"rvsGpCorrelation.png")    #print('throat r = ',pearsonr(x, y))    #print('masked throat r = ',pearsonr(x[maskThroatTD], y[maskThroatTD]))    maskPoreTD2 = abs(throatCA-TD)>14.999999    print('changed t Num = ',1-sum(maskPoreTD2)/NumberOfThroats)    #print('changed Vol = ',sum(maskPoreTD2*poreVolume)/sum(poreVolume))        plt.figure(4)    x = throatG    y = throatCA    plt.plot(x, y, '.',  markersize=2, color='black', alpha=0.025)    plt.xlabel('Throat G ', fontsize = 16)    plt.ylabel('Contact angle (°)', fontsize = 16)    plt.title('Contact angle vs Throat G')    if os.path.exists(inputAddres+"GtCorrelation.png"):        os.remove(inputAddres+"GtCorrelation.png")            plt.savefig(inputAddres+"GtCorrelation.png")        plt.figure(8)    x = throatG    y = throatRadius    plt.plot(x, y*1e6, '.',  markersize=2, color='black', alpha=0.025)    plt.xlabel('Throat G ', fontsize = 16)    plt.ylabel('Throat radius (${\\mu m}$) ', fontsize = 16)    plt.title('Throat radius vs Throat G')    if os.path.exists(inputAddres+"rvsGtCorrelation.png"):        os.remove(inputAddres+"rvsGtCorrelation.png")            plt.savefig(inputAddres+"rvsGtCorrelation.png")    #print(np.shape(poreLocation))    sU = (rInput+dInput)*1.0e-6    sL = (rInput-dInput)*1.0e-6    var_pCA = np.var(poreCA)#mean((poreCA - poreCA.mean())**2)    sumTerm1 = 0.0    sumTerm2 = 0.0    mask_d  = 0.0    print('rA_Average',2e6*np.sum(poreRadius)/NumberOfPores)    #print('rV_Average',np.sum(poreRadius*poreVolume)/(np.sum(poreVolume)))    print('rMax',2e6*max(poreRadius))    print('rMin',2e6*min(poreRadius))    plt.rc('font', family='serif')    plt.rcParams['axes.spines.right'] = False    plt.rcParams['axes.spines.top'] = False            #plt.rc('xtick', labelsize='x-small')    #plt.rc('ytick', labelsize='x-small')    #plt.rc('figure', titlesize='x-small')    #plt.rc('legend', fontsize='x-small')        plt.figure(5,figsize=(4,3))    bins=[15,22.5,30,37.8,47.3001,48.29999,57.5,65,72.5,80]    #bins = range(15,81)    #print(bins)    print("std Pores: ", np.std(poreCA))    hist, bin_edges = np.histogram(poreCA,bins) # make the histogram    x = (bin_edges[:-1]+bin_edges[1:])/2    y = hist/sum(hist)    x2=np.zeros(len(x)+2)    y2=np.zeros(len(y)+2)    x2[0] = 0    x2[1:-1]= x    x2[len(x)+1]=90    y2[0] = 0    y2[1:-1]=y    y2[len(y)+1]= 0    plt.plot(x2, y2)    thetaThermo = TD    plt.fill_between(x2,0,y2,color='silver', label='_nolegend_')    plt.plot([thetaThermo, thetaThermo],[0, 1.0],'r:',linewidth=1.0)    poreCAMaximimLimit = np.max(x)    #plt.xlim([np.min(x), poreCAMaximimLimit])    plt.xlim([0, 180])    plt.ylim([np.min(y), 0.6])#np.max(y)*1.1])    props = dict(boxstyle='round', facecolor='wheat', alpha=0.9)    plt.text(36, 0.57, '${\Theta}_{TD}$ = 47.8°',bbox=props)    plt.text(140, 0.55, 'Pores')#,fontsize=15)    print("Max. Pores : ",max(y2))    plt.xlabel('Contact angle (deg)');    plt.ylabel('Probability')    plt.tick_params(direction='in')    plt.tight_layout()    #plt.hist(poreCA, bins)    #plt.gca().set(title='Frequency Histogram', ylabel='Frequency')    if os.path.exists(inputAddres+"pCA_Hsit.png"):        os.remove(inputAddres+"pCA_Hsit.png")            plt.savefig(inputAddres+"pCA_Hsit.png", dpi=400)    if os.path.exists(inputAddres+"pCA_Hsit.eps"):        os.remove(inputAddres+"pCA_Hsit.eps")            plt.savefig(inputAddres+"pCA_Hsit.eps", format='eps', bbox_inches='tight')    plt.figure(6,figsize=(4,3))    bins=[15,22.5,30,37.8,47.3001,48.29999,57.5,65,72.5,80]    #bins = range(15,81)    #print(bins)    print("std Throats: ", np.std(throatCA))    hist, bin_edges = np.histogram(throatCA,bins) # make the histogram    x = (bin_edges[:-1]+bin_edges[1:])/2    y = hist/sum(hist)    x2=np.zeros(len(x)+2)    y2=np.zeros(len(y)+2)        x2[0] = 0    x2[1:-1]= x    x2[len(x)+1]=90    y2[0] = 0    y2[1:-1]=y    y2[len(y)+1]= 0    plt.plot(x2, y2)    thetaThermo = TD    plt.fill_between(x2,0,y2,color='silver', label='_nolegend_')    plt.plot([thetaThermo, thetaThermo],[0, 1.0],'r:',linewidth=1.0)    poreCAMaximimLimit = np.max(x)    #plt.xlim([np.min(x), poreCAMaximimLimit])    plt.xlim([0, 180])    plt.ylim([np.min(y), 0.6])#np.max(y)*1.1])    props = dict(boxstyle='round', facecolor='wheat', alpha=0.9)    plt.text(36, 0.57, '${\Theta}_{TD}$ = 47.8°',bbox=props)    plt.text(130, 0.55, 'Throats')#, fontsize=15)    print("Max. Throats : ",max(y2))        plt.xlabel('Contact angle (deg)');    plt.ylabel('Probability')    plt.tick_params(direction='in')    plt.tight_layout()    #plt.hist(poreCA, bins)    #plt.gca().set(title='Frequency Histogram', ylabel='Frequency')    if os.path.exists(inputAddres+"tCA_Hsit.png"):        os.remove(inputAddres+"tCA_Hsit.png")            plt.savefig(inputAddres+"tCA_Hsit.png", dpi=400)    if os.path.exists(inputAddres+"tCA_Hsit.eps"):        os.remove(inputAddres+"tCA_Hsit.eps")            plt.savefig(inputAddres+"tCA_Hsit.eps", format='eps', bbox_inches='tight')        for i in range(NumberOfPores):        d=((poreLocation[:,0]-poreLocation[i,0])**2+(poreLocation[:,1]-poreLocation[i,1])**2+(poreLocation[:,2]-poreLocation[i,2])**2)**0.5        mask_dU = d < sU        mask_dL = d > sL        mask_d = (1*mask_dU + 1*mask_dL)>1        sumTerm1 = sumTerm1 + np.sum(mask_d*(poreCA - poreCA[i])**2)        sumTerm2 = sumTerm2 + np.sum(mask_d)    print(sumTerm1/(2*var_pCA*sumTerm2))